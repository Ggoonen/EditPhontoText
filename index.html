<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ŸÖŸÑŸÉ ÿßŸÑÿ®ÿ≠ÿßÿ±</title>
    <!-- Google Fonts - Cairo -->
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700&display=swap" rel="stylesheet">
    <!-- Tailwind CSS CDN for basic styling and responsiveness -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom CSS for a better game appearance */
        body {
            font-family: 'Cairo', sans-serif; /* Apply Cairo font */
            background: linear-gradient(to bottom right, #0a192f, #000d1a); /* Dark blue gradient background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent scrolling */
        }
        .game-container {
            background-color: #0b203a; /* Darker blue for game area */
            border: 4px solid #4a90e2; /* Lighter blue border */
            border-radius: 1.5rem; /* More rounded corners */
            box-shadow: 0 0 30px rgba(74, 144, 226, 0.8), 0 0 15px rgba(74, 144, 226, 0.5) inset; /* Enhanced blue glow */
            padding: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            max-width: 90vw; /* Responsive width */
            width: 550px; /* Slightly wider for better view */
            position: relative; /* For absolute positioning of notifications */
        }
        canvas {
            background-color: #004d7a; /* Deeper blue for the sea */
            border-radius: 1rem; /* Rounded corners for canvas */
            display: block;
            touch-action: none; /* Disable default touch actions like scrolling/zooming */
            width: 100%; /* Make canvas responsive */
            height: 450px; /* Slightly taller game area */
            max-height: 75vh; /* Max height for responsiveness */
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5); /* Inner shadow for depth */
            /* Background animation for canvas */
            background-image: radial-gradient(circle at 50% 50%, rgba(255,255,255,0.05) 1px, transparent 1px);
            background-size: 20px 20px;
            animation: moveBackground 60s linear infinite;
        }
        @keyframes moveBackground {
            from { background-position: 0 0; }
            to { background-position: 0 1000px; } /* Move vertically */
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            color: #e0f2f7; /* Light cyan text color */
            font-size: 1.4rem; /* Slightly larger font */
            font-weight: bold;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5); /* Text shadow for readability */
        }
        .currency-display {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .currency-icon {
            width: 24px; /* Adjust size for better SVG display */
            height: 24px;
            vertical-align: middle;
            fill: currentColor; /* Inherit color from parent */
        }
        .message-box, .shop-modal, .main-menu-modal, .profile-modal, .my-items-modal, .cannon-game-modal {
            background-color: rgba(10, 25, 47, 0.95); /* Darker, semi-transparent background */
            color: #e0f2f7;
            padding: 1.5rem;
            border-radius: 1rem;
            text-align: center;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            /* Smooth transition properties */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            display: flex; /* Always flex, control visibility with opacity/visibility */
            flex-direction: column; /* For modals */
            gap: 1rem;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto; /* Allow scrolling for content */
        }
        .message-box.active, .shop-modal.active, .main-menu-modal.active, .profile-modal.active, .my-items-modal.active, .cannon-game-modal.active {
            opacity: 1;
            visibility: visible;
        }
        .button-group {
            display: flex;
            gap: 1.5rem;
        }
        .game-button {
            background: linear-gradient(145deg, #4a90e2, #2e6bb0); /* Blue gradient */
            color: white;
            padding: 0.9rem 2rem; /* Larger padding */
            border-radius: 1rem; /* More rounded */
            font-size: 1.25rem; /* Larger font */
            font-weight: bold;
            cursor: pointer;
            border: none;
            box-shadow: 0 6px 20px rgba(74, 144, 226, 0.5); /* Enhanced shadow */
            transition: all 0.3s ease;
            outline: none;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3); /* Text shadow on buttons */
        }
        .game-button:hover {
            background: linear-gradient(145deg, #2e6bb0, #4a90e2);
            box-shadow: 0 10px 25px rgba(74, 144, 226, 0.7);
            transform: translateY(-3px) scale(1.02); /* Slight lift and scale */
        }
        .game-button:active {
            transform: translateY(1px) scale(0.98);
            box-shadow: 0 4px 12px rgba(74, 144, 226, 0.4);
        }

        /* Shop specific styles */
        .shop-modal h2, .main-menu-modal h2, .profile-modal h2, .my-items-modal h2, .cannon-game-modal h2 {
            font-size: 2rem;
            color: #7dd3fc; /* Light blue for headings */
            margin-bottom: 1rem;
        }
        .shop-section, .profile-section, .my-items-section, .cannon-game-modal .game-info {
            margin-bottom: 2rem;
            width: 100%;
        }
        .shop-section h3, .profile-section h3, .my-items-section h3, .cannon-game-modal .game-info h3 {
            font-size: 1.6rem;
            color: #93c5fd; /* Slightly darker blue */
            margin-bottom: 1rem;
            border-bottom: 2px solid #3b82f6;
            padding-bottom: 0.5rem;
        }
        .skins-grid, .upgrades-grid, .main-menu-buttons, .my-items-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 1rem;
            justify-items: center;
        }
        .main-menu-buttons {
            grid-template-columns: 1fr; /* Stack buttons vertically in main menu */
            max-width: 250px; /* Limit width for menu buttons */
            margin: 0 auto;
        }
        .skin-item, .upgrade-item, .main-menu-item, .my-item-card {
            background-color: #1c2b46; /* Darker background for items */
            border-radius: 0.75rem;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s ease-in-out;
            text-align: center;
            cursor: pointer; /* Indicate clickable */
            padding: 0.75rem; /* Padding for items */
            width: 100%; /* Ensure items fill grid column */
        }
        .skin-item:hover, .upgrade-item:hover, .main-menu-item:hover, .my-item-card:hover {
            transform: translateY(-5px);
        }
        .skin-item.active {
            border-color: #10b981; /* Green border for active skin */
            box-shadow: 0 0 15px rgba(16, 185, 129, 0.7);
        }
        .skin-preview {
            width: 60px;
            height: 60px;
            margin: 0.5rem auto;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid;
            overflow: hidden; /* Hide overflow for custom shapes */
        }

        /* Power-up display */
        .powerups-display {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 5;
        }
        .powerup-item {
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        .powerup-icon {
            width: 20px;
            height: 20px;
            display: inline-block;
            vertical-align: middle;
        }

        /* In-game notification */
        #inGameNotification {
            position: absolute;
            top: 20px; /* Position below game info */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 1.1rem;
            z-index: 20;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease, visibility 0.5s ease;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
            white-space: nowrap; /* Prevent text wrapping */
        }
        #inGameNotification.active {
            opacity: 1;
            visibility: visible;
        }

        /* Profile specific styles */
        .profile-stats p {
            font-size: 1.2rem;
            margin-bottom: 0.5rem;
            color: #e0f2f7;
            text-align: left;
        }
        .profile-stats .currency-display {
            justify-content: flex-start;
        }
        .profile-stats .currency-icon {
            font-size: 1.5rem;
            width: 28px;
            height: 28px;
        }
        .xp-bar-container {
            width: 100%;
            background-color: #333;
            border-radius: 5px;
            height: 15px;
            margin-top: 5px;
            overflow: hidden;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
        }
        .xp-bar {
            height: 100%;
            background-color: #00BCD4; /* Cyan */
            width: 0%;
            border-radius: 5px;
            transition: width 0.5s ease-out;
        }

        /* Cannon Game Specific Styles */
        #cannonGameCanvas {
            background-color: #333; /* Dark background for cannon game */
            border-radius: 1rem;
            display: block;
            touch-action: none;
            width: 100%;
            height: 450px;
            max-height: 75vh;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
        }
        .cannon-game-controls {
            display: flex;
            justify-content: center;
            gap: 1rem;
            width: 100%;
        }

        /* Responsive adjustments */
        @media (max-width: 640px) {
            .game-container {
                padding: 1.2rem;
                width: 95vw;
                border-radius: 1rem;
            }
            canvas, #cannonGameCanvas {
                height: 350px; /* Adjust height for smaller screens */
                border-radius: 0.75rem;
            }
            .game-info {
                font-size: 1.1rem;
            }
            .game-button {
                padding: 0.7rem 1.5rem;
                font-size: 1.1rem;
                border-radius: 0.75rem;
            }
            .message-box, .shop-modal, .main-menu-modal, .profile-modal, .my-items-modal, .cannon-game-modal {
                font-size: 1.3rem;
                padding: 1rem;
                border-radius: 0.75rem;
            }
            .shop-modal h2, .main-menu-modal h2, .profile-modal h2, .my-items-modal h2, .cannon-game-modal h2 {
                font-size: 1.6rem;
            }
            .shop-section h3, .profile-section h3, .my-items-section h3, .cannon-game-modal .game-info h3 {
                font-size: 1.3rem;
            }
            .skins-grid, .upgrades-grid, .my-items-grid {
                grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            }
            .skin-preview {
                width: 50px;
                height: 50px;
            }
            .powerups-display {
                top: 5px;
                right: 5px;
                font-size: 0.8rem;
            }
            .powerup-icon {
                width: 16px;
                height: 16px;
            }
            #inGameNotification {
                top: 10px;
                font-size: 0.9rem;
                padding: 8px 15px;
            }
            .profile-stats p {
                font-size: 1rem;
            }
            .profile-stats .currency-icon {
                font-size: 1.2rem;
                width: 20px;
                height: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="text-4xl font-extrabold text-blue-300 mb-4 drop-shadow-lg">ŸÖŸÑŸÉ ÿßŸÑÿ®ÿ≠ÿßÿ±</h1>
        <div class="game-info">
            <div id="goldScore" class="currency-display text-yellow-400">
                <!-- Gold icon will be injected here -->
                ÿßŸÑÿ∞Ÿáÿ®: 0
            </div>
            <div id="dollarScore" class="currency-display text-green-400">
                <!-- Dollar icon will be injected here -->
                ÿßŸÑÿØŸàŸÑÿßÿ±: 0
            </div>
            <div id="highScore">ÿ£ÿπŸÑŸâ ÿ∞Ÿáÿ®: 0</div>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div class="button-group" id="gameButtons" style="display:none;">
            <button id="startButton" class="game-button">ÿßÿ®ÿØÿ£ ÿßŸÑŸÑÿπÿ®ÿ©</button>
            <button id="resetButton" class="game-button">ÿ•ÿπÿßÿØÿ© ÿßŸÑŸÑÿπÿ®</button>
            <button id="shopButton" class="game-button">ÿßŸÑŸÖÿ™ÿ¨ÿ±</button>
        </div>

        <!-- Main Menu Modal -->
        <div id="mainMenuModal" class="main-menu-modal active">
            <h2 class="text-blue-300">ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©</h2>
            <div class="main-menu-buttons">
                <button id="mainMenuPlayButton" class="game-button main-menu-item">ÿßÿ®ÿØÿ£ ÿßŸÑŸÑÿπÿ®</button>
                <button id="mainMenuShopButton" class="game-button main-menu-item">ÿßŸÑŸÖÿ™ÿ¨ÿ±</button>
                <button id="mainMenuProfileButton" class="game-button main-menu-item">ÿßŸÑŸÖŸÑŸÅ ÿßŸÑÿ¥ÿÆÿµŸä</button>
                <button id="mainMenuCannonGameButton" class="game-button main-menu-item">ŸÑÿπÿ®ÿ© ÿßŸÑŸÖÿØŸÅÿπ</button>
            </div>
        </div>

        <!-- Profile Modal -->
        <div id="profileModal" class="profile-modal">
            <h2 class="text-blue-300">ÿßŸÑŸÖŸÑŸÅ ÿßŸÑÿ¥ÿÆÿµŸä</h2>
            <div class="profile-stats flex flex-col items-start w-full px-4">
                <p class="currency-display text-yellow-400"><span class="currency-icon" id="profileGoldIcon"></span> ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑÿ∞Ÿáÿ® ÿßŸÑŸÖÿ¨ŸÖŸàÿπ: <span id="profileTotalGold">0</span></p>
                <p class="currency-display text-green-400"><span class="currency-icon" id="profileDollarIcon"></span> ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑÿØŸàŸÑÿßÿ± ÿßŸÑŸÖÿ¨ŸÖŸàÿπ: <span id="profileTotalDollars">0</span></p>
                <p>ÿ£ÿπŸÑŸâ ÿ±ÿµŸäÿØ ÿ∞Ÿáÿ®: <span id="profileHighScore">0</span></p>
                <p>ÿπÿØÿØ ÿßŸÑÿ£ŸÑÿπÿßÿ® ÿßŸÑÿ™Ÿä ŸÑÿπÿ®ÿ™Ÿáÿß: <span id="profileGamesPlayed">0</span></p>
                <p>ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ: <span id="playerLevelDisplay">1</span></p>
                <div class="xp-bar-container">
                    <div id="xpBar" class="xp-bar"></div>
                </div>
                <p class="text-xs text-gray-400 mt-1">XP: <span id="playerXPDisplay">0</span> / <span id="xpToNextLevelDisplay">100</span></p>
            </div>
            <button id="myItemsButton" class="game-button mt-4">ÿπŸÜÿßÿµÿ±Ÿä</button>
            <button id="profileCloseButton" class="game-button mt-4">ÿ•ÿ∫ŸÑÿßŸÇ</button>
        </div>

        <!-- My Items Modal -->
        <div id="myItemsModal" class="my-items-modal">
            <h2 class="text-blue-300">ÿπŸÜÿßÿµÿ±Ÿä</h2>
            <div class="my-items-section">
                <h3 class="text-blue-200">ÿ£ÿ¥ŸÉÿßŸÑ ÿßŸÑÿ≥ŸÅŸäŸÜÿ© ÿßŸÑŸÖŸÖŸÑŸàŸÉÿ©</h3>
                <div id="myPlayerSkinsContainer" class="my-items-grid skins-grid">
                    <!-- Owned player skins will be rendered here -->
                </div>
            </div>
            <div class="my-items-section">
                <h3 class="text-blue-200">ÿ£ÿ¥ŸÉÿßŸÑ ÿßŸÑÿπÿØŸà ÿßŸÑŸÖŸÖŸÑŸàŸÉÿ©</h3>
                <div id="myObstacleSkinsContainer" class="my-items-grid skins-grid">
                    <!-- Owned obstacle skins will be rendered here -->
                </div>
            </div>
            <div class="my-items-section">
                <h3 class="text-blue-200">ÿ™ÿ±ŸÇŸäÿßÿ™Ÿä</h3>
                <div id="myUpgradesContainer" class="my-items-grid upgrades-grid">
                    <!-- Owned upgrades will be rendered here -->
                </div>
            </div>
            <button id="resetGameDataButton" class="game-button mt-4 bg-red-600 hover:bg-red-700">ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™</button>
            <button id="myItemsCloseButton" class="game-button mt-4">ÿ•ÿ∫ŸÑÿßŸÇ</button>
        </div>


        <!-- Cannon Game Modal -->
        <div id="cannonGameModal" class="cannon-game-modal">
            <h2 class="text-blue-300">ŸÑÿπÿ®ÿ© ÿßŸÑŸÖÿØŸÅÿπ ÿßŸÑŸÖŸÑŸàŸÜ</h2>
            <div class="cannon-game-info flex justify-between w-full mb-4 text-white text-lg">
                <span>ÿßŸÑŸÜŸÇÿßÿ∑: <span id="cannonGameScoreDisplay">0</span></span>
                <span class="currency-display"><span class="currency-icon" id="cannonGameGoldIcon"></span> ÿßŸÑÿ∞Ÿáÿ®: <span id="cannonGameGoldRewardDisplay">0</span></span>
            </div>
            <canvas id="cannonGameCanvas"></canvas>
            <div class="cannon-game-controls mt-4">
                <button id="cannonGameBackButton" class="game-button">ÿßŸÑÿπŸàÿØÿ© ŸÑŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©</button>
            </div>
        </div>


        <!-- Power-ups Display -->
        <div id="powerupsDisplay" class="powerups-display">
            <!-- Active power-ups will be displayed here -->
        </div>

        <!-- In-game Notification -->
        <div id="inGameNotification"></div>

        <!-- Custom Message Box (for game over and shop messages) -->
        <div id="messageBox" class="message-box">
            <p id="messageText"></p>
            <button id="messageBoxClose" class="game-button mt-4">ÿ≠ÿ≥ŸÜÿßŸã</button>
        </div>

        <!-- Shop Modal -->
        <div id="shopModal" class="shop-modal">
            <h2 class="text-blue-300">ŸÖÿ™ÿ¨ÿ± ÿßŸÑÿ£ÿ¥ŸÉÿßŸÑ ŸàÿßŸÑÿ™ÿ±ŸÇŸäÿßÿ™</h2>
            <div class="flex justify-center gap-4 mb-4">
                <div id="shopCurrentGold" class="currency-display text-yellow-400 text-2xl font-bold">
                    <span class="currency-icon" id="shopGoldIcon"></span>
                    ÿßŸÑÿ∞Ÿáÿ® ÿßŸÑÿ≠ÿßŸÑŸä: 0
                </div>
                <div id="shopCurrentDollars" class="currency-display text-green-400 text-2xl font-bold">
                    <span class="currency-icon" id="shopDollarIcon"></span>
                    ÿßŸÑÿØŸàŸÑÿßÿ± ÿßŸÑÿ≠ÿßŸÑŸä: 0
                </div>
            </div>

            <div class="shop-section">
                <h3 class="text-blue-200">ÿ£ÿ¥ŸÉÿßŸÑ ÿßŸÑÿ≥ŸÅŸäŸÜÿ©</h3>
                <div id="playerSkinsContainer" class="skins-grid">
                    <!-- Player skins will be rendered here by JavaScript -->
                </div>
            </div>

            <div class="shop-section">
                <h3 class="text-blue-200">ÿ£ÿ¥ŸÉÿßŸÑ ÿßŸÑÿπÿØŸà (ÿßŸÑÿµÿÆŸàÿ±)</h3>
                <div id="obstacleSkinsContainer" class="skins-grid">
                    <!-- Obstacle skins will be rendered here by JavaScript -->
                </div>
            </div>

            <div class="shop-section">
                <h3 class="text-blue-200">ÿßŸÑÿ™ÿ±ŸÇŸäÿßÿ™</h3>
                <div id="upgradesContainer" class="upgrades-grid">
                    <!-- Upgrades will be rendered here by JavaScript -->
                </div>
            </div>

            <button id="shopCloseButton" class="game-button mt-4">ÿ•ÿ∫ŸÑÿßŸÇ</button>
        </div>
    </div>

    <script>
        // Get canvas and its context for Sea King game
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Get elements for Sea King game UI
        const goldScoreDisplay = document.getElementById('goldScore');
        const dollarScoreDisplay = document.getElementById('dollarScore');
        const highScoreDisplay = document.getElementById('highScore');
        const gameButtons = document.getElementById('gameButtons');
        const startButton = document.getElementById('startButton');
        const resetButton = document.getElementById('resetButton');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const messageBoxClose = document.getElementById('messageBoxClose');
        const inGameNotification = document.getElementById('inGameNotification');

        // Main Menu elements
        const mainMenuModal = document.getElementById('mainMenuModal');
        const mainMenuPlayButton = document.getElementById('mainMenuPlayButton');
        const mainMenuShopButton = document.getElementById('mainMenuShopButton');
        const mainMenuProfileButton = document.getElementById('mainMenuProfileButton');
        const mainMenuCannonGameButton = document.getElementById('mainMenuCannonGameButton'); // New button for Cannon Game

        // Profile elements
        const profileModal = document.getElementById('profileModal');
        const profileTotalGold = document.getElementById('profileTotalGold');
        const profileTotalDollars = document.getElementById('profileTotalDollars');
        const profileHighScore = document.getElementById('profileHighScore');
        const profileGamesPlayed = document.getElementById('profileGamesPlayed');
        const playerLevelDisplay = document.getElementById('playerLevelDisplay');
        const playerXPDisplay = document.getElementById('playerXPDisplay');
        const xpToNextLevelDisplay = document.getElementById('xpToNextLevelDisplay');
        const xpBar = document.getElementById('xpBar');
        const myItemsButton = document.getElementById('myItemsButton');
        const profileCloseButton = document.getElementById('profileCloseButton');

        // My Items elements
        const myItemsModal = document.getElementById('myItemsModal');
        const myPlayerSkinsContainer = document.getElementById('myPlayerSkinsContainer');
        const myObstacleSkinsContainer = document.getElementById('myObstacleSkinsContainer');
        const myUpgradesContainer = document.getElementById('myUpgradesContainer');
        const resetGameDataButton = document.getElementById('resetGameDataButton');
        const myItemsCloseButton = document.getElementById('myItemsCloseButton');

        // Shop UI elements
        const shopButton = document.getElementById('shopButton');
        const shopModal = document.getElementById('shopModal');
        const shopCloseButton = document.getElementById('shopCloseButton');
        const playerSkinsContainer = document.getElementById('playerSkinsContainer');
        const obstacleSkinsContainer = document.getElementById('obstacleSkinsContainer');
        const upgradesContainer = document.getElementById('upgradesContainer');
        const shopCurrentGoldDisplay = document.getElementById('shopCurrentGold');
        const shopCurrentDollarsDisplay = document.getElementById('shopCurrentDollars');

        // Cannon Game elements
        const cannonGameModal = document.getElementById('cannonGameModal');
        const cannonGameCanvas = document.getElementById('cannonGameCanvas');
        const cannonCtx = cannonGameCanvas.getContext('2d');
        const cannonGameScoreDisplay = document.getElementById('cannonGameScoreDisplay');
        const cannonGameGoldRewardDisplay = document.getElementById('cannonGameGoldRewardDisplay');
        const cannonGameBackButton = document.getElementById('cannonGameBackButton');
        document.getElementById('cannonGameGoldIcon').insertAdjacentHTML('afterbegin', '<svg class="currency-icon text-yellow-400" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v2h-2zm0 4h2v6h-2z"/></svg>');


        // Currency Icons (SVG) - Defined once for reuse
        const goldIconSVG = '<svg class="currency-icon text-yellow-400" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v2h-2zm0 4h2v6h-2z"/></svg>';
        const dollarIconSVG = '<svg class="currency-icon text-green-400" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v2h-2zm0 4h2v6h-2zM10 9h4v2h-4V9zm0 4h4v2h-4v-2z"/></svg>';

        // Inject icons into HTML
        goldScoreDisplay.insertAdjacentHTML('afterbegin', goldIconSVG);
        dollarScoreDisplay.insertAdjacentHTML('afterbegin', dollarIconSVG);
        document.getElementById('shopGoldIcon').insertAdjacentHTML('afterbegin', goldIconSVG);
        document.getElementById('shopDollarIcon').insertAdjacentHTML('afterbegin', dollarIconSVG);
        document.getElementById('profileGoldIcon').insertAdjacentHTML('afterbegin', goldIconSVG);
        document.getElementById('profileDollarIcon').insertAdjacentHTML('afterbegin', dollarIconSVG);


        // Power-ups display element
        const powerupsDisplay = document.getElementById('powerupsDisplay');

        // Game variables (Sea King)
        let player = {
            x: canvas.width / 2,
            y: canvas.height - 60,
            width: 40,
            height: 40,
            speed: 5, // Base speed, will be modified by upgrades
            dx: 0,
            isInvulnerable: false,
            hasMagnet: false,
            magnetRange: 200, // Base magnet range
            magnetPullSpeedMultiplier: 1.5, // Base magnet pull speed
            isDashing: false,
            dashSpeedMultiplier: 3
        };

        let fallingObjects = [];
        let gold = 0;
        let dollars = 0;
        let highScore = localStorage.getItem('seaKingHighScore') || 0;
        let totalGoldCollected = parseInt(localStorage.getItem('seaKingTotalGoldCollected') || '0');
        let totalDollarsCollected = parseInt(localStorage.getItem('seaKingTotalDollarsCollected') || '0');
        let gamesPlayed = parseInt(localStorage.getItem('seaKingGamesPlayed') || '0');

        let playerLevel = parseInt(localStorage.getItem('seaKingPlayerLevel') || '1');
        let playerXP = parseInt(localStorage.getItem('seaKingPlayerXP') || '0');

        // XP required for each level (up to level 100)
        const xpToNextLevel = Array(100).fill(0).map((_, i) => 100 + (i * 50) + (Math.floor(i / 10) * 200));

        let gameRunning = false; // Controls Sea King game loop
        let lastObjectTime = 0;
        const OBJECT_SPAWN_INTERVAL = 900;
        const OBJECT_SPEED_INCREMENT = 0.07;
        const MAX_OBJECT_SPEED = 10; // Cap the max speed of falling objects

        let activePowerups = [];

        // Permanent upgrade effects
        let goldMultiplier = 1;
        let obstacleSpeedReduction = 0;
        let luckyCharmChance = 0;

        // --- Cannon Game Variables ---
        let cannonGameRunning = false;
        let cannonGameScore = 0;
        let cannonGoldReward = 0;
        let cannonBalls = [];
        let cannonTargets = [];
        const CANNON_COLORS = ['red', 'green', 'blue', 'yellow'];
        let cannon = {
            x: cannonGameCanvas.width / 2,
            y: cannonGameCanvas.height - 30,
            width: 60,
            height: 20,
            angle: Math.PI / 2, // 90 degrees (straight up)
            color: 'gray',
            rotationSpeed: 0.05
        };
        let currentCannonBallColor = CANNON_COLORS[0];
        let cannonTargetSpawnInterval = 1500;
        let lastCannonTargetTime = 0;
        const CANNON_BALL_RADIUS = 15;
        const CANNON_BALL_SPEED = 8;
        const CANNON_TARGET_SIZE = 40;
        const CANNON_TARGET_ROWS = 3;
        const CANNON_TARGET_COLUMNS = 5;
        const CANNON_TARGET_SPACING = 10;
        let cannonGameLevel = 1; // For increasing difficulty in cannon game
        let cannonGameScoreToGold = 500; // Score needed for 1 gold

        // --- Drawing Functions for Skins (Sea King) ---

        /**
         * Draws the default ship shape.
         */
        function drawShipDefault(ctx, x, y, width, height, color, detailsColor) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.roundRect(x - width / 2, y, width, height, 8);
            ctx.moveTo(x - width / 2, y);
            ctx.lineTo(x, y - height / 2);
            ctx.lineTo(x + width / 2, y);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = detailsColor;
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.fillStyle = detailsColor;
            ctx.fillRect(x - 5, y + 10, 10, 15);
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.strokeRect(x - 5, y + 10, 10, 15);
        }

        /**
         * Draws a sleek, fast ship shape.
         */
        function drawShipFast(ctx, x, y, width, height, color, detailsColor) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x - width * 0.4, y + height);
            ctx.lineTo(x + width * 0.4, y + height);
            ctx.lineTo(x + width * 0.5, y + height * 0.2);
            ctx.lineTo(x, y);
            ctx.lineTo(x - width * 0.5, y + height * 0.2);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = detailsColor;
            ctx.lineWidth = 3;
            ctx.stroke();
            // Cockpit
            ctx.fillStyle = detailsColor;
            ctx.beginPath();
            ctx.arc(x, y + height * 0.4, width * 0.15, 0, Math.PI * 2);
            ctx.fill();
        }

        /**
         * Draws a wide, sturdy tanker ship shape.
         */
        function drawShipTanker(ctx, x, y, width, height, color, detailsColor) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.roundRect(x - width / 2, y, width, height, 10);
            ctx.fill();
            ctx.strokeStyle = detailsColor;
            ctx.lineWidth = 4;
            ctx.stroke();
            // Containers
            ctx.fillStyle = detailsColor;
            ctx.fillRect(x - width * 0.4, y + height * 0.2, width * 0.8, height * 0.2);
            ctx.fillRect(x - width * 0.4, y + height * 0.6, width * 0.8, height * 0.2);
        }

        /**
         * Draws a stealthy, angular ship.
         */
        function drawShipStealth(ctx, x, y, width, height, color, detailsColor) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x - width * 0.5, y + height * 0.8);
            ctx.lineTo(x + width * 0.5, y + height * 0.8);
            ctx.lineTo(x + width * 0.3, y + height * 0.2);
            ctx.lineTo(x, y);
            ctx.lineTo(x - width * 0.3, y + height * 0.2);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = detailsColor;
            ctx.lineWidth = 2;
            ctx.stroke();
            // Window
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.beginPath();
            ctx.moveTo(x - width * 0.1, y + height * 0.3);
            ctx.lineTo(x + width * 0.1, y + height * 0.3);
            ctx.lineTo(x + width * 0.05, y + height * 0.15);
            ctx.lineTo(x - width * 0.05, y + height * 0.15);
            ctx.closePath();
            ctx.fill();
        }

        /**
         * Draws a royal, ornate ship.
         */
        function drawShipRoyal(ctx, x, y, width, height, color, detailsColor) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.ellipse(x, y + height * 0.7, width * 0.4, height * 0.2, 0, 0, Math.PI * 2); // Base
            ctx.fill();
            ctx.strokeStyle = detailsColor;
            ctx.lineWidth = 3;
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(x - width * 0.3, y + height * 0.7);
            ctx.lineTo(x - width * 0.1, y + height * 0.1);
            ctx.lineTo(x, y);
            ctx.lineTo(x + width * 0.1, y + height * 0.1);
            ctx.lineTo(x + width * 0.3, y + height * 0.7);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Crown-like top
            ctx.fillStyle = '#FFD700'; // Gold
            ctx.beginPath();
            ctx.moveTo(x - width * 0.15, y - height * 0.1);
            ctx.lineTo(x - width * 0.05, y - height * 0.2);
            ctx.lineTo(x, y - height * 0.1);
            ctx.lineTo(x + width * 0.05, y - height * 0.2);
            ctx.lineTo(x + width * 0.15, y - height * 0.1);
            ctx.lineTo(x + width * 0.1, y);
            ctx.lineTo(x - width * 0.1, y);
            ctx.closePath();
            ctx.fill();
        }


        /**
         * Draws the default rock shape.
         */
        function drawRockDefault(ctx, x, y, width, height, color, detailsColor) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x + width / 2, y);
            ctx.lineTo(x + width, y + height / 3);
            ctx.lineTo(x + width * 0.8, y + height);
            ctx.lineTo(x + width * 0.2, y + height);
            ctx.lineTo(x, y + height / 3);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = detailsColor;
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        /**
         * Draws a spiky rock shape.
         */
        function drawRockSpiky(ctx, x, y, width, height, color, detailsColor) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x + width / 2, y);
            ctx.lineTo(x + width, y + height * 0.2);
            ctx.lineTo(x + width * 0.8, y + height * 0.5);
            ctx.lineTo(x + width, y + height * 0.8);
            ctx.lineTo(x + width / 2, y + height);
            ctx.lineTo(x, y + height * 0.8);
            ctx.lineTo(x + width * 0.2, y + height * 0.5);
            ctx.lineTo(x, y + height * 0.2);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = detailsColor;
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        /**
         * Draws a log shape.
         */
        function drawRockLog(ctx, x, y, width, height, color, detailsColor) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.roundRect(x, y + height * 0.2, width, height * 0.6, 10);
            ctx.fill();
            ctx.strokeStyle = detailsColor;
            ctx.lineWidth = 3;
            ctx.stroke();
            // Add some lines for wood texture
            ctx.beginPath();
            ctx.strokeStyle = detailsColor;
            ctx.lineWidth = 1;
            ctx.moveTo(x + width * 0.2, y + height * 0.3);
            ctx.lineTo(x + width * 0.2, y + height * 0.7);
            ctx.moveTo(x + width * 0.5, y + height * 0.25);
            ctx.lineTo(x + width * 0.5, y + height * 0.75);
            ctx.moveTo(x + width * 0.8, y + height * 0.3);
            ctx.lineTo(x + width * 0.8, y + height * 0.7);
            ctx.stroke();
        }

        /**
         * Draws a crystal-like rock.
         */
        function drawRockCrystal(ctx, x, y, width, height, color, detailsColor) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x + width / 2, y);
            ctx.lineTo(x + width, y + height * 0.2);
            ctx.lineTo(x + width * 0.7, y + height);
            ctx.lineTo(x + width * 0.3, y + height);
            ctx.lineTo(x, y + height * 0.2);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = detailsColor;
            ctx.lineWidth = 2;
            ctx.stroke();
            // Inner lines for crystal effect
            ctx.beginPath();
            ctx.moveTo(x + width / 2, y);
            ctx.lineTo(x + width * 0.5, y + height * 0.5);
            ctx.lineTo(x + width * 0.7, y + height);
            ctx.moveTo(x + width / 2, y);
            ctx.lineTo(x + width * 0.5, y + height * 0.5);
            ctx.lineTo(x + width * 0.3, y + height);
            ctx.moveTo(x + width / 2, y);
            ctx.lineTo(x + width * 0.5, y + height * 0.5);
            ctx.lineTo(x, y + height * 0.2);
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.stroke();
        }

        /**
         * Draws an alien, organic rock.
         */
        function drawRockAlien(ctx, x, y, width, height, color, detailsColor) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = detailsColor;
            ctx.lineWidth = 3;
            ctx.stroke();
            // Tentacles/spikes
            ctx.beginPath();
            ctx.moveTo(x + width / 2, y);
            ctx.quadraticCurveTo(x + width * 0.7, y - height * 0.2, x + width * 0.8, y + height * 0.1);
            ctx.moveTo(x + width / 2, y + height);
            ctx.quadraticCurveTo(x + width * 0.3, y + height * 1.2, x + width * 0.2, y + height * 0.9);
            ctx.strokeStyle = detailsColor;
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        /**
         * Draws an explosive mine.
         */
        function drawMine(ctx, x, y, size, color = '#FF5722', detailsColor = '#E64A19') { // Orange/Red
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x + size / 2, y + size / 2, size / 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = detailsColor;
            ctx.lineWidth = 2;
            ctx.stroke();

            // Spikes
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI / 4) * i;
                const startX = x + size / 2 + Math.cos(angle) * (size / 2 - 5);
                const startY = y + size / 2 + Math.sin(angle) * (size / 2 - 5);
                const endX = x + size / 2 + Math.cos(angle) * (size / 2 + 10);
                const endY = y + size / 2 + Math.sin(angle) * (size / 2 + 10);
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.strokeStyle = detailsColor;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        /**
         * Draws a whirlpool.
         */
        function drawWhirlpool(ctx, x, y, size, color = '#4FC3F7', detailsColor = '#0288D1') { // Light Blue / Dark Blue
            ctx.save();
            ctx.translate(x + size / 2, y + size / 2); // Center for rotation

            ctx.strokeStyle = detailsColor;
            ctx.lineWidth = 3;

            // Spirals
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.arc(0, 0, size * 0.4, 0 + i * Math.PI / 3, Math.PI + i * Math.PI / 3);
                ctx.stroke();
            }

            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.2, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }


        /**
         * Draws a speed power-up (green arrow).
         */
        function drawPowerupSpeed(ctx, x, y, size) {
            ctx.fillStyle = '#4CAF50'; // Green
            ctx.beginPath();
            ctx.moveTo(x + size / 2, y);
            ctx.lineTo(x + size, y + size / 2);
            ctx.lineTo(x + size / 2, y + size);
            ctx.lineTo(x + size / 2, y + size * 0.7);
            ctx.lineTo(x, y + size * 0.7);
            ctx.lineTo(x, y + size * 0.3);
            ctx.lineTo(x + size / 2, y + size * 0.3);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#388E3C';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        /**
         * Draws a shield power-up (blue shield).
         */
        function drawPowerupShield(ctx, x, y, size) {
            ctx.fillStyle = '#2196F3'; // Blue
            ctx.beginPath();
            ctx.moveTo(x, y + size * 0.2);
            ctx.lineTo(x + size / 2, y);
            ctx.lineTo(x + size, y + size * 0.2);
            ctx.lineTo(x + size, y + size * 0.8);
            ctx.quadraticCurveTo(x + size / 2, y + size, x, y + size * 0.8);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#1976D2';
            ctx.lineWidth = 2;
            ctx.stroke();
            // Small star in the middle
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(x + size / 2, y + size / 2, size * 0.15, 0, Math.PI * 2);
            ctx.fill();
        }

        /**
         * Draws a gold magnet power-up (purple magnet).
         */
        function drawPowerupMagnet(ctx, x, y, size) {
            ctx.fillStyle = '#9C27B0'; // Purple
            ctx.beginPath();
            ctx.roundRect(x, y + size * 0.2, size, size * 0.6, 5); // Main body
            ctx.fill();
            ctx.strokeStyle = '#7B1FA2';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Magnet arms
            ctx.beginPath();
            ctx.arc(x, y + size / 2, size * 0.3, Math.PI / 2, Math.PI * 1.5);
            ctx.lineTo(x, y + size * 0.2);
            ctx.fill();
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(x + size, y + size / 2, size * 0.3, Math.PI * 1.5, Math.PI / 2);
            ctx.lineTo(x + size, y + size * 0.2);
            ctx.fill();
            ctx.stroke();

            // Poles
            ctx.fillStyle = '#F44336'; // Red pole
            ctx.fillRect(x, y + size * 0.2, size * 0.1, size * 0.6);
            ctx.fillStyle = '#2196F3'; // Blue pole
            ctx.fillRect(x + size * 0.9, y + size * 0.2, size * 0.1, size * 0.6);
        }

        /**
         * Draws a magnet boost power-up (stronger magnet).
         */
        function drawPowerupMagnetBoost(ctx, x, y, size) {
            drawPowerupMagnet(ctx, x, y, size); // Draw base magnet
            ctx.fillStyle = 'rgba(255, 255, 0, 0.7)'; // Yellow glow
            ctx.beginPath();
            ctx.arc(x + size / 2, y + size / 2, size * 0.4, 0, Math.PI * 2);
            ctx.fill();
        }

        /**
         * Draws an invincible dash power-up (rocket).
         */
        function drawPowerupDash(ctx, x, y, size) {
            ctx.fillStyle = '#FF4081'; // Pink/Red
            ctx.beginPath();
            ctx.moveTo(x + size / 2, y); // Top point
            ctx.lineTo(x + size * 0.8, y + size * 0.8);
            ctx.lineTo(x + size * 0.7, y + size);
            ctx.lineTo(x + size * 0.3, y + size);
            ctx.lineTo(x + size * 0.2, y + size * 0.8);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#C51162';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Fins
            ctx.fillStyle = '#FFAB40'; // Orange
            ctx.beginPath();
            ctx.moveTo(x + size * 0.2, y + size * 0.7);
            ctx.lineTo(x, y + size);
            ctx.lineTo(x + size * 0.2, y + size);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(x + size * 0.8, y + size * 0.7);
            ctx.lineTo(x + size, y + size);
            ctx.lineTo(x + size * 0.8, y + size);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }


        /**
         * Draws a clear screen power-up (explosion icon).
         */
        function drawPowerupClearScreen(ctx, x, y, size) {
            ctx.fillStyle = '#E91E63'; // Pink
            ctx.beginPath();
            ctx.arc(x + size / 2, y + size / 2, size / 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#C2185B';
            ctx.lineWidth = 2;
            ctx.stroke();
            // Starburst lines
            ctx.beginPath();
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI / 4) * i;
                ctx.moveTo(x + size / 2 + Math.cos(angle) * size * 0.2, y + size / 2 + Math.sin(angle) * size * 0.2);
                ctx.lineTo(x + size / 2 + Math.cos(angle) * size * 0.4, y + size / 2 + Math.sin(angle) * size * 0.4);
            }
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        /**
         * Draws a treasure chest.
         */
        function drawTreasureChest(ctx, x, y, size) {
            ctx.fillStyle = '#8B4513'; // SaddleBrown
            ctx.beginPath();
            ctx.roundRect(x, y + size * 0.2, size, size * 0.6, 5); // Body
            ctx.fill();
            ctx.strokeStyle = '#5A2D0C'; // Darker brown
            ctx.lineWidth = 2;
            ctx.stroke();

            // Lid
            ctx.fillStyle = '#A0522D'; // Sienna
            ctx.beginPath();
            ctx.roundRect(x, y, size, size * 0.3, 5);
            ctx.fill();
            ctx.strokeStyle = '#5A2D0C';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Gold lock
            ctx.fillStyle = '#FFD700'; // Gold
            ctx.fillRect(x + size / 2 - 5, y + size * 0.4, 10, 10);
            ctx.strokeStyle = '#B8860B';
            ctx.lineWidth = 1;
            ctx.strokeRect(x + size / 2 - 5, y + size * 0.4, 10, 10);
        }


        // Skin data - Define available skins and their properties
        const playerSkinsData = [
            { id: 'ship-default', name: 'ÿßŸÑÿ≥ŸÅŸäŸÜÿ© ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ©', cost: { gold: 0, dollars: 0 }, color: '#ffeb3b', detailsColor: '#fbc02d', isOwned: true, isActive: true, drawFunction: drawShipDefault },
            { id: 'ship-blue', name: 'ÿßŸÑÿ≥ŸÅŸäŸÜÿ© ÿßŸÑÿ≤ÿ±ŸÇÿßÿ°', cost: { gold: 50, dollars: 0 }, color: '#4a90e2', detailsColor: '#2e6bb0', isOwned: false, isActive: false, drawFunction: drawShipDefault },
            { id: 'ship-green', name: 'ÿßŸÑÿ≥ŸÅŸäŸÜÿ© ÿßŸÑÿÆÿ∂ÿ±ÿßÿ°', cost: { gold: 100, dollars: 0 }, color: '#8bc34a', detailsColor: '#689f38', isOwned: false, isActive: false, drawFunction: drawShipDefault },
            { id: 'ship-fast', name: 'ÿßŸÑÿ≥ŸÅŸäŸÜÿ© ÿßŸÑÿ≥ÿ±Ÿäÿπÿ©', cost: { gold: 200, dollars: 0 }, color: '#ff5722', detailsColor: '#e64a19', isOwned: false, isActive: false, drawFunction: drawShipFast },
            { id: 'ship-tanker', name: 'ÿ≥ŸÅŸäŸÜÿ© ÿßŸÑÿ¥ÿ≠ŸÜ', cost: { gold: 300, dollars: 0 }, color: '#607d8b', detailsColor: '#455a64', isOwned: false, isActive: false, drawFunction: drawShipTanker },
            { id: 'ship-stealth', name: 'ÿ≥ŸÅŸäŸÜÿ© ÿßŸÑÿ™ÿÆŸÅŸä', cost: { gold: 0, dollars: 8 }, color: '#37474F', detailsColor: '#263238', isOwned: false, isActive: false, drawFunction: drawShipStealth },
            { id: 'ship-royal', name: 'ÿßŸÑÿ≥ŸÅŸäŸÜÿ© ÿßŸÑŸÖŸÑŸÉŸäÿ©', cost: { gold: 0, dollars: 15 }, color: '#FFD700', detailsColor: '#DAA520', isOwned: false, isActive: false, drawFunction: drawShipRoyal }
        ];

        const obstacleSkinsData = [
            { id: 'rock-default', name: 'ÿßŸÑÿµÿÆÿ±ÿ© ÿßŸÑÿπÿßÿØŸäÿ©', cost: { gold: 0, dollars: 0 }, color: '#ef5350', detailsColor: '#d32f2f', isOwned: true, isActive: true, drawFunction: drawRockDefault },
            { id: 'rock-purple', name: 'ÿßŸÑÿµÿÆÿ±ÿ© ÿßŸÑÿ£ÿ±ÿ¨ŸàÿßŸÜŸäÿ©', cost: { gold: 75, dollars: 0 }, color: '#9c27b0', detailsColor: '#7b1fa2', isOwned: false, isActive: false, drawFunction: drawRockDefault },
            { id: 'rock-grey', name: 'ÿßŸÑÿµÿÆÿ±ÿ© ÿßŸÑÿ±ŸÖÿßÿØŸäÿ©', cost: { gold: 120, dollars: 0 }, color: '#757575', detailsColor: '#424242', isOwned: false, isActive: false, drawFunction: drawRockDefault },
            { id: 'rock-spiky', name: 'ÿßŸÑÿµÿÆÿ±ÿ© ÿßŸÑÿ¥ŸàŸÉŸäÿ©', cost: { gold: 170, dollars: 0 }, color: '#795548', detailsColor: '#5d4037', isOwned: false, isActive: false, drawFunction: drawRockSpiky },
            { id: 'rock-log', name: 'ÿ¨ÿ∞ÿπ ÿßŸÑÿ¥ÿ¨ÿ±ÿ©', cost: { gold: 220, dollars: 0 }, color: '#8d6e63', detailsColor: '#6d4c41', isOwned: false, isActive: false, drawFunction: drawRockLog },
            { id: 'rock-crystal', name: 'ÿßŸÑÿµÿÆÿ±ÿ© ÿßŸÑŸÉÿ±Ÿäÿ≥ÿ™ÿßŸÑŸäÿ©', cost: { gold: 0, dollars: 7 }, color: '#00BCD4', detailsColor: '#0097A7', isOwned: false, isActive: false, drawFunction: drawRockCrystal },
            { id: 'rock-alien', name: 'ÿßŸÑÿµÿÆÿ±ÿ© ÿßŸÑŸÅÿ∂ÿßÿ¶Ÿäÿ©', cost: { gold: 0, dollars: 12 }, color: '#6A1B9A', detailsColor: '#4A148C', isOwned: false, isActive: false, drawFunction: drawRockAlien }
        ];

        const powerupData = [
            { id: 'speed-boost', name: 'ÿ≥ÿ±ÿπÿ© ÿ•ÿ∂ÿßŸÅŸäÿ©', duration: 5000, drawFunction: drawPowerupSpeed, effect: () => { player.speed *= 2; }, revert: () => { player.speed /= 2; }, icon: '‚ö°' },
            { id: 'shield', name: 'ÿØÿ±ÿπ ÿ≠ŸÖÿßŸäÿ©', duration: 7000, drawFunction: drawPowerupShield, effect: () => { player.isInvulnerable = true; }, revert: () => { player.isInvulnerable = false; }, icon: 'üõ°Ô∏è' },
            { id: 'gold-magnet', name: 'ÿ¨ÿßÿ∞ÿ® ÿßŸÑÿ∞Ÿáÿ®', duration: 6000, drawFunction: drawPowerupMagnet, effect: () => { player.hasMagnet = true; }, revert: () => { player.hasMagnet = false; }, icon: 'üß≤' },
            { id: 'magnet-boost', name: 'ÿ™ÿπÿ≤Ÿäÿ≤ ÿßŸÑÿ¨ÿßÿ∞ÿ®Ÿäÿ©', duration: 4000, drawFunction: drawPowerupMagnetBoost, effect: () => { player.hasMagnet = true; player.magnetRange *= 1.5; player.magnetPullSpeedMultiplier *= 1.5; }, revert: () => { player.hasMagnet = false; player.magnetRange /= 1.5; player.magnetPullSpeedMultiplier /= 1.5; }, icon: 'üß≤‚ú®' }, // New power-up
            { id: 'invincible-dash', name: 'ÿßŸÜÿØŸÅÿßÿπ ÿÆÿßÿ±ŸÇ', duration: 1500, drawFunction: drawPowerupDash, effect: () => { player.isDashing = true; player.isInvulnerable = true; player.speed *= player.dashSpeedMultiplier; }, revert: () => { player.isDashing = false; player.isInvulnerable = false; player.speed /= player.dashSpeedMultiplier; }, icon: 'üöÄ' },
            { id: 'clear-screen', name: 'ŸÖÿ≥ÿ≠ ÿßŸÑÿ¥ÿßÿ¥ÿ©', duration: 0, drawFunction: drawPowerupClearScreen, effect: () => { fallingObjects = fallingObjects.filter(obj => obj.type !== 'obstacle' && obj.type !== 'mine' && obj.type !== 'whirlpool'); showInGameNotification('ÿ™ŸÖ ŸÖÿ≥ÿ≠ ÿßŸÑÿπŸÇÿ®ÿßÿ™!'); }, revert: () => {}, icon: 'üí•' }
        ];

        // New: Upgrade data
        const upgradesData = [
            { id: 'upgrade-speed', name: 'ÿ™ÿ±ŸÇŸäÿ© ÿßŸÑÿ≥ÿ±ÿπÿ©', description: 'ÿ≤ŸäÿßÿØÿ© ÿ≥ÿ±ÿπÿ© ÿßŸÑÿ≥ŸÅŸäŸÜÿ© ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ©.', levels: [ { cost: 300, value: 1 }, { cost: 700, value: 1 }, { cost: 1500, value: 1 }, { cost: 3000, value: 1 }, { cost: 6000, value: 1 } ], currentLevel: 0, maxLevel: 5 },
            { id: 'upgrade-magnet', name: 'ÿ™ÿ±ŸÇŸäÿ© ÿ¨ÿßÿ∞ÿ® ÿßŸÑÿ∞Ÿáÿ®', description: 'ÿ≤ŸäÿßÿØÿ© ŸÖÿØÿ© ÿ¨ÿßÿ∞ÿ® ÿßŸÑÿ∞Ÿáÿ®.', levels: [ { cost: 350, value: 1500 }, { cost: 800, value: 1500 }, { cost: 1800, value: 1500 }, { cost: 3800, value: 1500 }, { cost: 7500, value: 1500 } ], currentLevel: 0, maxLevel: 5 },
            { id: 'upgrade-shield', name: 'ÿ™ÿ±ŸÇŸäÿ© ÿßŸÑÿØÿ±ÿπ', description: 'ÿ≤ŸäÿßÿØÿ© ŸÖÿØÿ© ÿØÿ±ÿπ ÿßŸÑÿ≠ŸÖÿßŸäÿ©.', levels: [ { cost: 400, value: 2000 }, { cost: 900, value: 2000 }, { cost: 2000, value: 2000 }, { cost: 4200, value: 2000 }, { cost: 8500, value: 2000 } ], currentLevel: 0, maxLevel: 5 },
            { id: 'upgrade-gold-multiplier', name: 'ŸÖÿ∂ÿßÿπŸÅ ÿßŸÑÿ∞Ÿáÿ®', description: 'ÿ≤ŸäÿßÿØÿ© ÿßŸÑÿ∞Ÿáÿ® ÿßŸÑŸÖŸÉÿ™ÿ≥ÿ®.', levels: [ { cost: 500, value: 0.2 }, { cost: 1200, value: 0.3 }, { cost: 2500, value: 0.4 }, { cost: 5500, value: 0.5 }, { cost: 11000, value: 0.6 } ], currentLevel: 0, maxLevel: 5 },
            { id: 'upgrade-obstacle-slowdown', name: 'ÿ•ÿ®ÿ∑ÿßÿ° ÿßŸÑÿπŸÇÿ®ÿßÿ™', description: 'ÿ™ŸÇŸÑŸäŸÑ ÿ≥ÿ±ÿπÿ© ÿ≥ŸÇŸàÿ∑ ÿßŸÑÿπŸÇÿ®ÿßÿ™.', levels: [ { cost: 480, value: 0.03 }, { cost: 1100, value: 0.04 }, { cost: 2400, value: 0.05 }, { cost: 5200, value: 0.06 }, { cost: 10500, value: 0.07 } ], currentLevel: 0, maxLevel: 5 },
            { id: 'upgrade-lucky-charm', name: 'ÿßŸÑÿ™ŸÖŸäŸÖÿ© ÿßŸÑŸÖÿ≠ÿ∏Ÿàÿ∏ÿ©', description: 'ŸÅÿ±ÿµÿ© ŸÑŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿØŸàŸÑÿßÿ± ÿπŸÜÿØ ÿ¨ŸÖÿπ ÿßŸÑÿ∞Ÿáÿ®.', levels: [ { cost: { gold: 0, dollars: 3 }, value: 0.01 }, { cost: { gold: 0, dollars: 6 }, value: 0.01 }, { cost: { gold: 0, dollars: 10 }, value: 0.01 } ], currentLevel: 0, maxLevel: 3 }
        ];


        let playerSkins = [];
        let obstacleSkins = [];
        let gameUpgrades = [];

        let currentEquippedPlayerSkinId = 'ship-default';
        let currentEquippedObstacleSkinId = 'rock-default';

        // --- Game Functions (Sea King) ---

        /**
         * Calculates XP needed for a given level.
         * @param {number} level - The target level.
         * @returns {number} XP required for that level.
         */
        function getXpForLevel(level) {
            if (level <= 0) return 0;
            if (level > xpToNextLevel.length) return Infinity; // Max level reached
            return xpToNextLevel[level - 1];
        }

        /**
         * Adds XP to the player and handles level ups.
         * @param {number} amount - The amount of XP to add.
         */
        function addXP(amount) {
            playerXP += amount;
            while (playerLevel < 100 && playerXP >= getXpForLevel(playerLevel)) {
                playerXP -= getXpForLevel(playerLevel);
                playerLevel++;
                showInGameNotification(`ÿßÿ±ÿ™ŸÅÿπ ŸÖÿ≥ÿ™ŸàÿßŸÉ ÿ•ŸÑŸâ ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ ${playerLevel}!`);
            }
            if (playerLevel >= 100) { // Cap level at 100
                playerLevel = 100;
                playerXP = 0; // No more XP needed at max level
            }
            saveGameData(); // Save XP and level
            updateProfileDisplay(); // Update profile UI
        }

        /**
         * Loads game data (skins, high score, current gold, dollars, upgrades) from localStorage.
         */
        function loadGameData() {
            gold = parseInt(localStorage.getItem('seaKingGold') || '0');
            dollars = parseInt(localStorage.getItem('seaKingDollars') || '0');
            highScore = parseInt(localStorage.getItem('seaKingHighScore') || '0');
            totalGoldCollected = parseInt(localStorage.getItem('seaKingTotalGoldCollected') || '0');
            totalDollarsCollected = parseInt(localStorage.getItem('seaKingTotalDollarsCollected') || '0');
            gamesPlayed = parseInt(localStorage.getItem('seaKingGamesPlayed') || '0');
            playerLevel = parseInt(localStorage.getItem('seaKingPlayerLevel') || '1');
            playerXP = parseInt(localStorage.getItem('seaKingPlayerXP') || '0');


            goldScoreDisplay.textContent = `ÿßŸÑÿ∞Ÿáÿ®: ${gold}`;
            dollarScoreDisplay.textContent = `ÿßŸÑÿØŸàŸÑÿßÿ±: ${dollars}`;
            highScoreDisplay.textContent = `ÿ£ÿπŸÑŸâ ÿ∞Ÿáÿ®: ${highScore}`;

            // Always start with fresh copies that include draw functions
            playerSkins = JSON.parse(JSON.stringify(playerSkinsData));
            obstacleSkins = JSON.parse(JSON.stringify(obstacleSkinsData));
            gameUpgrades = JSON.parse(JSON.stringify(upgradesData));

            // Re-attach draw functions to the deep copies for skins
            playerSkins.forEach((skin, index) => {
                skin.drawFunction = playerSkinsData[index].drawFunction;
            });
            obstacleSkins.forEach((skin, index) => {
                skin.drawFunction = obstacleSkinsData[index].drawFunction;
            });
            // Re-attach powerup functions
            powerupData.forEach((powerup, index) => {
                powerup.drawFunction = powerupData[index].drawFunction;
                powerup.effect = powerupData[index].effect;
                powerup.revert = powerupData[index].revert;
            });


            const savedPlayerSkins = JSON.parse(localStorage.getItem('playerSkins'));
            const savedObstacleSkins = JSON.parse(localStorage.getItem('obstacleSkins'));
            const savedGameUpgrades = JSON.parse(localStorage.getItem('gameUpgrades'));
            const savedEquippedPlayerSkinId = localStorage.getItem('currentEquippedPlayerSkinId');
            const savedEquippedObstacleSkinId = localStorage.getItem('currentEquippedObstacleSkinId');

            // Update properties from saved data for skins
            if (savedPlayerSkins) {
                savedPlayerSkins.forEach(savedSkin => {
                    const existingSkin = playerSkins.find(s => s.id === savedSkin.id);
                    if (existingSkin) {
                        existingSkin.isOwned = savedSkin.isOwned;
                    }
                });
            }

            if (savedObstacleSkins) {
                savedObstacleSkins.forEach(savedSkin => {
                    const existingSkin = obstacleSkins.find(s => s.id === savedSkin.id);
                    if (existingSkin) {
                        existingSkin.isOwned = savedSkin.isOwned;
                    }
                });
            }

            // Update properties from saved data for upgrades
            if (savedGameUpgrades) {
                savedGameUpgrades.forEach(savedUpgrade => {
                    const existingUpgrade = gameUpgrades.find(u => u.id === savedUpgrade.id);
                    if (existingUpgrade) {
                        existingUpgrade.currentLevel = savedUpgrade.currentLevel;
                    }
                });
            }


            // Set active player skin
            playerSkins.forEach(skin => skin.isActive = false); // Deactivate all first
            if (savedEquippedPlayerSkinId) {
                currentEquippedPlayerSkinId = savedEquippedPlayerSkinId;
                const activeSkin = playerSkins.find(skin => skin.id === currentEquippedPlayerSkinId);
                if (activeSkin) activeSkin.isActive = true;
                else playerSkins[0].isActive = true; // Fallback to default if saved skin not found
            } else {
                playerSkins[0].isActive = true; // Default is active if no saved one
            }

            // Set active obstacle skin
            obstacleSkins.forEach(skin => skin.isActive = false); // Deactivate all first
            if (savedEquippedObstacleSkinId) {
                currentEquippedObstacleSkinId = savedEquippedObstacleSkinId;
                const activeSkin = obstacleSkins.find(skin => skin.id === currentEquippedObstacleSkinId);
                if (activeSkin) activeSkin.isActive = true;
                else obstacleSkins[0].isActive = true; // Fallback to default if saved skin not found
            } else {
                obstacleSkins[0].isActive = true; // Default is active if no saved one
            }

            // Apply permanent upgrade effects after loading
            applyPermanentUpgrades();
        }

        /**
         * Saves game data (skins, high score, current gold, dollars, upgrades) to localStorage.
         */
        function saveGameData() {
            localStorage.setItem('seaKingGold', gold);
            localStorage.setItem('seaKingDollars', dollars);
            localStorage.setItem('seaKingHighScore', highScore);
            localStorage.setItem('seaKingTotalGoldCollected', totalGoldCollected);
            localStorage.setItem('seaKingTotalDollarsCollected', totalDollarsCollected);
            localStorage.setItem('seaKingGamesPlayed', gamesPlayed);
            localStorage.setItem('seaKingPlayerLevel', playerLevel);
            localStorage.setItem('seaKingPlayerXP', playerXP);

            // Remove drawFunction before saving as functions cannot be stringified
            const serializablePlayerSkins = playerSkins.map(({ drawFunction, ...rest }) => rest);
            const serializableObstacleSkins = obstacleSkins.map(({ drawFunction, ...rest }) => rest);
            localStorage.setItem('playerSkins', JSON.stringify(serializablePlayerSkins));
            localStorage.setItem('obstacleSkins', JSON.stringify(serializableObstacleSkins));
            localStorage.setItem('gameUpgrades', JSON.stringify(gameUpgrades));
            localStorage.setItem('currentEquippedPlayerSkinId', currentEquippedPlayerSkinId);
            localStorage.setItem('currentEquippedObstacleSkinId', currentEquippedObstacleSkinId);
        }

        /**
         * Applies permanent effects from upgrades. Call this after loading game data.
         */
        function applyPermanentUpgrades() {
            const speedUpgrade = gameUpgrades.find(u => u.id === 'upgrade-speed');
            player.speed = 5 + (speedUpgrade ? speedUpgrade.currentLevel * speedUpgrade.levels[0].value : 0);

            const goldMultiplierUpgrade = gameUpgrades.find(u => u.id === 'upgrade-gold-multiplier');
            goldMultiplier = 1 + (goldMultiplierUpgrade ? goldMultiplierUpgrade.levels.slice(0, goldMultiplierUpgrade.currentLevel).reduce((sum, level) => sum + level.value, 0) : 0);

            const obstacleSlowdownUpgrade = gameUpgrades.find(u => u.id === 'upgrade-obstacle-slowdown');
            obstacleSpeedReduction = (obstacleSlowdownUpgrade ? obstacleSlowdownUpgrade.levels.slice(0, obstacleSlowdownUpgrade.currentLevel).reduce((sum, level) => sum + level.value, 0) : 0);

            const luckyCharmUpgrade = gameUpgrades.find(u => u.id === 'upgrade-lucky-charm');
            luckyCharmChance = (luckyCharmUpgrade ? luckyCharmUpgrade.levels.slice(0, luckyCharmUpgrade.currentLevel).reduce((sum, level) => sum + level.value, 0) : 0);
        }

        /**
         * Shows a custom message box (for game over and shop errors) with the given text.
         * @param {string} message - The message to display.
         */
        function showMessageBox(message) {
            messageText.innerHTML = message; // Use innerHTML for SVG icons
            messageBox.classList.add('active'); // Add active class for transition
        }

        /**
         * Hides the custom message box.
         */
        function hideMessageBox() {
            messageBox.classList.remove('active'); // Remove active class for transition
        }

        /**
         * Shows a small, temporary notification at the top of the screen during gameplay.
         * @param {string} message - The message to display.
         * @param {number} duration - Duration in milliseconds (default 2000).
         */
        function showInGameNotification(message, duration = 2000) {
            inGameNotification.textContent = message;
            inGameNotification.classList.add('active');
            setTimeout(() => {
                inGameNotification.classList.remove('active');
            }, duration);
        }

        /**
         * Draws the player ship on the canvas using the currently equipped skin's draw function.
         */
        function drawPlayer() {
            const activeSkin = playerSkins.find(s => s.isActive);
            if (!activeSkin || !activeSkin.drawFunction) {
                console.error("No active player skin or draw function found. Falling back to default.");
                drawShipDefault(ctx, player.x, player.y, player.width, player.height, '#ffeb3b', '#fbc02d');
                return;
            }
            activeSkin.drawFunction(ctx, player.x, player.y, player.width, player.height, activeSkin.color, activeSkin.detailsColor);

            // Draw shield effect if invulnerable
            if (player.isInvulnerable) {
                ctx.strokeStyle = 'rgba(173, 216, 230, 0.8)'; // Light blue, semi-transparent
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.arc(player.x, player.y + player.height / 2, player.width * 0.8, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        /**
         * Creates a new falling object (obstacle, collectible, or power-up) and adds it to the array.
         */
        function createFallingObject() {
            const rand = Math.random();
            let type;
            // Probabilities: Obstacle (55%), Gold (25%), Power-up (10%), Mine (4.5%), Whirlpool (4%), Dollar (0.9%), Treasure Chest (0.1%)
            if (rand < 0.55) {
                type = 'obstacle';
            } else if (rand < 0.80) { // 0.55 + 0.25 = 0.80
                type = 'collectible'; // Gold
            } else if (rand < 0.90) { // 0.80 + 0.10 = 0.90
                type = 'powerup';
            } else if (rand < 0.95) { // 0.90 + 0.05 = 0.95
                type = 'mine'; // Explosive Mine
            } else if (rand < 0.99) { // 0.95 + 0.04 = 0.99
                type = 'whirlpool'; // New Whirlpool obstacle
            } else if (rand < 0.999) { // 0.99 + 0.009 = 0.999
                type = 'dollar'; // Rare Dollar
            } else { // 0.999 + 0.001 = 1.0
                type = 'treasure-chest'; // Very rare Treasure Chest
            }


            const objectWidth = (type === 'obstacle' || type === 'mine' || type === 'whirlpool') ? (35 + Math.random() * 45) : (type === 'treasure-chest' ? 40 : 25);
            const objectHeight = (type === 'obstacle' || type === 'mine' || type === 'whirlpool') ? (35 + Math.random() * 45) : (type === 'treasure-chest' ? 40 : 25);
            const objectX = Math.random() * (canvas.width - objectWidth);
            let objectSpeed = 2 + Math.floor(gold / 10) * OBJECT_SPEED_INCREMENT; // Base speed scales with gold
            objectSpeed *= (1 - obstacleSpeedReduction); // Apply permanent obstacle slowdown upgrade
            objectSpeed = Math.min(objectSpeed, MAX_OBJECT_SPEED); // Cap maximum speed

            let powerupDetails = null;
            if (type === 'powerup') {
                const randomPowerupIndex = Math.floor(Math.random() * powerupData.length);
                powerupDetails = powerupData[randomPowerupIndex];
            }

            fallingObjects.push({
                x: objectX,
                y: -objectHeight,
                width: objectWidth,
                height: objectHeight,
                speed: objectSpeed,
                type: type,
                powerup: powerupDetails // Store power-up details if it's a power-up
            });
        }

        /**
         * Draws all falling objects on the canvas using the currently equipped obstacle skin's draw function.
         */
        function drawFallingObjects() {
            const activeObstacleSkin = obstacleSkins.find(s => s.isActive);
            if (!activeObstacleSkin || !activeObstacleSkin.drawFunction) {
                console.error("No active obstacle skin or draw function found. Falling back to default.");
                drawRockDefault(ctx, -100, -100, 40, 40, '#ef5350', '#d32f2f'); // Draw off-screen to avoid visual clutter
                return;
            }

            fallingObjects.forEach(obj => {
                if (obj.type === 'obstacle') {
                    activeObstacleSkin.drawFunction(ctx, obj.x, obj.y, obj.width, obj.height, activeObstacleSkin.color, activeObstacleSkin.detailsColor);
                } else if (obj.type === 'mine') {
                    drawMine(ctx, obj.x, obj.y, obj.width);
                } else if (obj.type === 'whirlpool') {
                    drawWhirlpool(ctx, obj.x, obj.y, obj.width);
                }
                else if (obj.type === 'collectible') { // Gold coin
                    ctx.fillStyle = '#ffd700'; // Gold color
                    ctx.beginPath();
                    ctx.arc(obj.x + obj.width / 2, obj.y + obj.height / 2, obj.width / 2, 0, Math.PI * 2); // Circle
                    ctx.fill();
                    ctx.strokeStyle = '#b8860b'; // Darker gold border
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    // Add a small star or shine effect on the coin
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.beginPath();
                    ctx.arc(obj.x + obj.width * 0.7, obj.y + obj.height * 0.3, obj.width * 0.1, 0, Math.PI * 2);
                    ctx.fill();
                } else if (obj.type === 'powerup' && obj.powerup && obj.powerup.drawFunction) {
                    obj.powerup.drawFunction(ctx, obj.x, obj.y, obj.width); // Power-ups draw based on their own function
                } else if (obj.type === 'dollar') { // Dollar
                    drawDollar(ctx, obj.x, obj.y, obj.width);
                } else if (obj.type === 'treasure-chest') { // Treasure Chest
                    drawTreasureChest(ctx, obj.x, obj.y, obj.width);
                }
            });
        }

        /**
         * Updates the position of player and falling objects, handles collisions.
         */
        function update() {
            if (!gameRunning) return;

            // Update player position
            player.x += player.dx;

            // Keep player within canvas bounds
            if (player.x - player.width / 2 < 0) {
                player.x = player.width / 2;
            }
            if (player.x + player.width / 2 > canvas.width) {
                player.x = canvas.width - player.width / 2;
            }

            // Update falling object positions and handle collisions/removal
            fallingObjects = fallingObjects.filter(obj => {
                // Apply magnet effect if active
                if (player.hasMagnet && obj.type === 'collectible') {
                    const dx = player.x - obj.x;
                    const dy = player.y - obj.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < player.magnetRange) { // Magnet range
                        obj.x += (dx / distance) * (obj.speed * player.magnetPullSpeedMultiplier); // Pull faster
                        obj.y += (dy / distance) * (obj.speed * player.magnetPullSpeedMultiplier);
                    } else {
                        obj.y += obj.speed;
                    }
                } else {
                    obj.y += obj.speed;
                }

                // Apply whirlpool effect
                if (obj.type === 'whirlpool') {
                    const dx = player.x - (obj.x + obj.width / 2);
                    const dy = player.y - (obj.y + obj.height / 2);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const pullStrength = 0.5; // How strongly the whirlpool pulls
                    const whirlpoolRadius = obj.width * 1.5; // Radius of pull effect

                    if (distance < whirlpoolRadius) {
                        player.x -= (dx / distance) * pullStrength;
                        player.y -= (dy / distance) * pullStrength;
                    }
                }


                // Check for collision with player
                if (
                    player.x - player.width / 2 < obj.x + obj.width &&
                    player.x + player.width / 2 > obj.x &&
                    player.y < obj.y + obj.height &&
                    player.y + player.height > obj.y
                ) {
                    if (obj.type === 'obstacle' || obj.type === 'whirlpool') {
                        if (!player.isInvulnerable) { // Only end game if not invulnerable
                            endGame(); // Collision with obstacle ends game
                        } else {
                            showInGameNotification('ÿßŸÑÿØÿ±ÿπ Ÿäÿ≠ŸÖŸäŸÉ!');
                        }
                        return false; // Remove obstacle/whirlpool regardless
                    } else if (obj.type === 'mine') {
                        // Mine explodes on contact, regardless of shield
                        showInGameNotification('ÿßŸÜŸÅÿ¨ÿßÿ± ŸÑÿ∫ŸÖ!');
                        // Clear nearby objects
                        fallingObjects = fallingObjects.filter(otherObj => {
                            const dist = Math.sqrt(Math.pow((obj.x + obj.width/2) - (otherObj.x + otherObj.width/2), 2) + Math.pow((obj.y + obj.height/2) - (otherObj.y + otherObj.height/2), 2));
                            return dist > 150; // Remove objects within 150px radius
                        });
                        if (!player.isInvulnerable) { // Still takes damage if not shielded
                            endGame();
                        }
                        return false; // Remove mine
                    }
                    else if (obj.type === 'collectible') { // Gold
                        const goldAmount = Math.floor(Math.random() * 4) + 1; // 1 to 4 gold
                        const finalGold = Math.round(goldAmount * goldMultiplier * 1.15); // Apply multiplier and 15% bonus
                        gold += finalGold;
                        totalGoldCollected += finalGold; // Update total collected gold
                        addXP(finalGold); // Add XP for gold collected
                        goldScoreDisplay.textContent = `ÿßŸÑÿ∞Ÿáÿ®: ${gold}`;
                        saveGameData(); // Save gold immediately
                        showInGameNotification(`+${finalGold} ÿ∞Ÿáÿ®!`);

                        // Lucky Charm chance
                        if (luckyCharmChance > 0 && Math.random() < luckyCharmChance) {
                            dollars++;
                            totalDollarsCollected++;
                            addXP(5); // Add XP for rare dollar
                            dollarScoreDisplay.textContent = `ÿßŸÑÿØŸàŸÑÿßÿ±: ${dollars}`;
                            showInGameNotification(`+1 ÿØŸàŸÑÿßÿ± ŸÖŸÜ ÿßŸÑÿ™ŸÖŸäŸÖÿ© ÿßŸÑŸÖÿ≠ÿ∏Ÿàÿ∏ÿ©!`);
                        }
                        return false; // Remove collectible
                    } else if (obj.type === 'powerup' && obj.powerup) { // Power-up
                        applyPowerup(obj.powerup);
                        return false; // Remove power-up
                    } else if (obj.type === 'dollar') { // Dollar
                        dollars++;
                        totalDollarsCollected++;
                        addXP(10); // Add XP for dollar collected
                        dollarScoreDisplay.textContent = `ÿßŸÑÿØŸàŸÑÿßÿ±: ${dollars}`;
                        saveGameData();
                        showInGameNotification(`+1 ÿØŸàŸÑÿßÿ±!`);
                        return false; // Remove dollar
                    } else if (obj.type === 'treasure-chest') { // Treasure Chest
                        const treasureGold = Math.floor(Math.random() * 31) + 20; // 20-50 gold
                        gold += treasureGold;
                        totalGoldCollected += treasureGold;
                        addXP(treasureGold * 0.5); // Half XP for treasure gold
                        goldScoreDisplay.textContent = `ÿßŸÑÿ∞Ÿáÿ®: ${gold}`;
                        saveGameData();
                        showInGameNotification(`+${treasureGold} ÿ∞Ÿáÿ® ŸÖŸÜ ÿµŸÜÿØŸàŸÇ ÿßŸÑŸÉŸÜÿ≤!`);

                        if (Math.random() < 0.5) { // 50% chance for a dollar
                            dollars++;
                            totalDollarsCollected++;
                            addXP(10); // Add XP for dollar from treasure
                            dollarScoreDisplay.textContent = `ÿßŸÑÿØŸàŸÑÿßÿ±: ${dollars}`;
                            showInGameNotification(`+1 ÿØŸàŸÑÿßÿ± ŸÖŸÜ ÿµŸÜÿØŸàŸÇ ÿßŸÑŸÉŸÜÿ≤!`);
                        }
                        return false; // Remove treasure chest
                    }
                }

                // Remove object if it goes off-screen
                if (obj.y > canvas.height) {
                    return false;
                }
                return true; // Keep object
            });

            // Spawn new objects
            const currentTime = Date.now();
            if (currentTime - lastObjectTime > OBJECT_SPAWN_INTERVAL) {
                createFallingObject();
                lastObjectTime = currentTime;
            }

            // Update active power-ups and revert if expired
            activePowerups = activePowerups.filter(p => {
                if (currentTime >= p.endTime) {
                    p.revert();
                    showInGameNotification(`ÿßŸÜÿ™ŸáŸâ ÿ™ÿ£ÿ´Ÿäÿ±: ${p.name}`);
                    return false; // Remove expired power-up
                }
                return true; // Keep active power-up
            });
            updatePowerupsDisplay(); // Update UI for active power-ups
        }

        /**
         * Clears the canvas and redraws all game elements.
         */
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas
            drawPlayer();
            drawFallingObjects();
        }

        /**
         * Main game loop (Sea King).
         */
        function gameLoop() {
            try {
                update();
                draw();
            } catch (error) {
                console.error("Error in Sea King game loop:", error);
                endGame(); // End game on error to prevent freezing
                showMessageBox("ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑŸÑÿπÿ®ÿ©! ÿ™ŸÖ ÿ•ŸäŸÇÿßŸÅ ÿßŸÑŸÑÿπÿ®.");
            }

            if (gameRunning) {
                requestAnimationFrame(gameLoop); // Continue loop if game is running
            }
        }

        /**
         * Applies a power-up effect.
         * @param {object} powerup - The power-up object.
         */
        function applyPowerup(powerup) {
            // Special handling for instant power-ups like 'clear-screen'
            if (powerup.id === 'clear-screen') {
                powerup.effect(); // Apply effect immediately
                return; // No duration, no need to add to activePowerups
            }

            // Remove any existing power-up of the same type before applying new one
            activePowerups = activePowerups.filter(p => {
                if (p.id === powerup.id) {
                    p.revert(); // Revert old effect
                    return false;
                }
                return true;
            });

            // Apply base effect
            powerup.effect();

            // Apply upgrade duration if available
            let actualDuration = powerup.duration;
            // For magnet and shield, value is directly added to duration
            if (powerup.id === 'gold-magnet') {
                const upgrade = gameUpgrades.find(u => u.id === 'upgrade-magnet');
                if (upgrade && upgrade.currentLevel > 0) {
                    actualDuration += upgrade.levels.slice(0, upgrade.currentLevel).reduce((sum, level) => sum + level.value, 0);
                }
            } else if (powerup.id === 'shield') {
                const upgrade = gameUpgrades.find(u => u.id === 'upgrade-shield');
                if (upgrade && upgrade.currentLevel > 0) {
                    actualDuration += upgrade.levels.slice(0, upgrade.currentLevel).reduce((sum, level) => sum + level.value, 0);
                }
            }
            // Speed boost and dash duration are fixed unless specific upgrades for them are added

            activePowerups.push({
                id: powerup.id,
                name: powerup.name,
                icon: powerup.icon,
                revert: powerup.revert,
                endTime: Date.now() + actualDuration
            });
            updatePowerupsDisplay();
        }

        /**
         * Updates the display of active power-ups.
         */
        function updatePowerupsDisplay() {
            powerupsDisplay.innerHTML = '';
            const currentTime = Date.now();
            activePowerups.forEach(p => {
                const remainingTime = Math.ceil((p.endTime - currentTime) / 1000);
                const powerupDiv = document.createElement('div');
                powerupDiv.className = 'powerup-item';
                powerupDiv.innerHTML = `
                    <span class="powerup-icon">${p.icon}</span>
                    <span>${p.name} (${remainingTime}s)</span>
                `;
                powerupsDisplay.appendChild(powerupDiv);
            });
        }

        /**
         * Starts the Sea King game.
         */
        function startGame() {
            // Hide all modals
            mainMenuModal.classList.remove('active');
            shopModal.classList.remove('active');
            profileModal.classList.remove('active');
            myItemsModal.classList.remove('active');
            cannonGameModal.classList.remove('active');

            // Show Sea King game elements
            canvas.style.display = 'block'; // Ensure canvas is visible
            gameButtons.style.display = 'flex'; // Ensure game buttons are visible
            goldScoreDisplay.style.display = 'flex';
            dollarScoreDisplay.style.display = 'flex';
            highScoreDisplay.style.display = 'block';
            powerupsDisplay.style.display = 'flex';


            player.x = canvas.width / 2;
            player.y = canvas.height - 60;

            // Apply permanent upgrades at start of game
            applyPermanentUpgrades();

            player.isInvulnerable = false; // Reset invulnerability
            player.hasMagnet = false; // Reset magnet
            player.isDashing = false; // Reset dashing
            player.magnetRange = 200; // Reset magnet range
            player.magnetPullSpeedMultiplier = 1.5; // Reset magnet pull speed

            // Revert any lingering power-up effects
            activePowerups.forEach(p => p.revert());
            activePowerups = []; // Clear active power-ups
            updatePowerupsDisplay(); // Clear UI

            fallingObjects = []; // Clear all objects
            gold = parseInt(localStorage.getItem('seaKingGold') || '0'); // Load gold on start
            dollars = parseInt(localStorage.getItem('seaKingDollars') || '0'); // Load dollars on start
            goldScoreDisplay.textContent = `ÿßŸÑÿ∞Ÿáÿ®: ${gold}`;
            dollarScoreDisplay.textContent = `ÿßŸÑÿØŸàŸÑÿßÿ±: ${dollars}`;

            gamesPlayed++; // Increment games played
            saveGameData(); // Save updated games played

            gameRunning = true; // Start Sea King game loop
            startButton.style.display = 'none';
            resetButton.style.display = 'inline-block';
            shopButton.style.display = 'none'; // Hide shop button during game
            hideMessageBox(); // Hide any existing message box
            lastObjectTime = Date.now(); // Reset object spawn timer
            gameLoop();
        }

        /**
         * Ends the Sea King game.
         */
        function endGame() {
            gameRunning = false; // Stop Sea King game loop
            // Revert any lingering power-up effects
            activePowerups.forEach(p => p.revert());
            activePowerups = []; // Clear active power-ups
            updatePowerupsDisplay(); // Clear UI

            if (gold > highScore) {
                highScore = gold;
                localStorage.setItem('seaKingHighScore', highScore); // Save new high score
                highScoreDisplay.textContent = `ÿ£ÿπŸÑŸâ ÿ∞Ÿáÿ®: ${highScore}`;
                showMessageBox(`ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÑÿπÿ®ÿ©! ŸÑŸÇÿØ ÿ¨ŸÖÿπÿ™ ${gold} ÿ∞Ÿáÿ®ÿßŸã Ÿàÿ≠ŸÇŸÇÿ™ ÿ±ŸÇŸÖÿßŸã ŸÇŸäÿßÿ≥ŸäÿßŸã ÿ¨ÿØŸäÿØÿßŸã!`);
            } else {
                showMessageBox(`ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÑÿπÿ®ÿ©! ŸÑŸÇÿØ ÿ¨ŸÖÿπÿ™ ${gold} ÿ∞Ÿáÿ®ÿßŸã.`);
            }
            resetButton.style.display = 'inline-block';
            shopButton.style.display = 'inline-block'; // Show shop button after game
            gameButtons.style.display = 'flex'; // Ensure buttons are visible
            saveGameData(); // Ensure all data is saved on game end

            // Hide game elements and show main menu after a short delay
            setTimeout(() => {
                canvas.style.display = 'none';
                gameButtons.style.display = 'none';
                goldScoreDisplay.style.display = 'none';
                dollarScoreDisplay.style.display = 'none';
                highScoreDisplay.style.display = 'none';
                powerupsDisplay.style.display = 'none';
                mainMenuModal.classList.add('active');
            }, 1500); // Small delay before showing main menu
        }

        // --- Profile Functions ---
        function openProfile() {
            // Hide all other modals
            mainMenuModal.classList.remove('active');
            shopModal.classList.remove('active');
            myItemsModal.classList.remove('active');
            cannonGameModal.classList.remove('active');

            // Hide Sea King game elements
            canvas.style.display = 'none';
            gameButtons.style.display = 'none';
            goldScoreDisplay.style.display = 'none';
            dollarScoreDisplay.style.display = 'none';
            highScoreDisplay.style.display = 'none';
            powerupsDisplay.style.display = 'none';

            profileModal.classList.add('active');
            updateProfileDisplay();
        }

        function updateProfileDisplay() {
            profileTotalGold.textContent = totalGoldCollected;
            profileTotalDollars.textContent = totalDollarsCollected;
            profileHighScore.textContent = highScore;
            profileGamesPlayed.textContent = gamesPlayed;
            playerLevelDisplay.textContent = playerLevel;
            playerXPDisplay.textContent = playerXP;
            xpToNextLevelDisplay.textContent = getXpForLevel(playerLevel);

            const xpPercentage = (playerLevel <= 100) ? (playerXP / getXpForLevel(playerLevel)) * 100 : 100;
            xpBar.style.width = `${xpPercentage}%`;
        }

        function openMyItems() {
            profileModal.classList.remove('active');
            myItemsModal.classList.add('active');
            renderMyItems();
        }

        function renderMyItems() {
            myPlayerSkinsContainer.innerHTML = '';
            myObstacleSkinsContainer.innerHTML = '';
            myUpgradesContainer.innerHTML = '';

            // Owned Player Skins
            playerSkins.filter(skin => skin.isOwned).forEach(skin => {
                const skinDiv = document.createElement('div');
                skinDiv.className = `my-item-card p-3 border rounded-lg flex flex-col items-center gap-2 ${skin.isActive ? 'active border-green-500' : 'border-gray-700'}`;

                const previewCanvas = document.createElement('canvas');
                previewCanvas.width = 60;
                previewCanvas.height = 60;
                previewCanvas.className = 'skin-preview';
                const previewCtx = previewCanvas.getContext('2d');
                previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                previewCtx.save();
                const scale = 0.8;
                previewCtx.translate(previewCanvas.width / 2, previewCanvas.height / 2);
                previewCtx.scale(scale, scale);
                previewCtx.translate(-previewCanvas.width / 2, -previewCanvas.height / 2);
                const previewYOffset = skin.id.startsWith('ship') ? 10 : 0;
                skin.drawFunction(previewCtx, previewCanvas.width / 2, previewCanvas.height / 2 + previewYOffset, 40, 40, skin.color, skin.detailsColor);
                previewCtx.restore();

                skinDiv.appendChild(previewCanvas);
                const nameSpan = document.createElement('span');
                nameSpan.className = 'text-white text-sm font-bold';
                nameSpan.textContent = skin.name;
                skinDiv.appendChild(nameSpan);
                myPlayerSkinsContainer.appendChild(skinDiv);
            });

            // Owned Obstacle Skins
            obstacleSkins.filter(skin => skin.isOwned).forEach(skin => {
                const skinDiv = document.createElement('div');
                skinDiv.className = `my-item-card p-3 border rounded-lg flex flex-col items-center gap-2 ${skin.isActive ? 'active border-green-500' : 'border-gray-700'}`;

                const previewCanvas = document.createElement('canvas');
                previewCanvas.width = 60;
                previewCanvas.height = 60;
                previewCanvas.className = 'skin-preview';
                const previewCtx = previewCanvas.getContext('2d');
                previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                previewCtx.save();
                const scale = 0.8;
                previewCtx.translate(previewCanvas.width / 2, previewCanvas.height / 2);
                previewCtx.scale(scale, scale);
                previewCtx.translate(-previewCanvas.width / 2, -previewCanvas.height / 2);
                skin.drawFunction(previewCtx, previewCanvas.width / 2, previewCanvas.height / 2, 40, 40, skin.color, skin.detailsColor);
                previewCtx.restore();

                skinDiv.appendChild(previewCanvas);
                const nameSpan = document.createElement('span');
                nameSpan.className = 'text-white text-sm font-bold';
                nameSpan.textContent = skin.name;
                skinDiv.appendChild(nameSpan);
                myObstacleSkinsContainer.appendChild(skinDiv);
            });

            // Owned Upgrades
            gameUpgrades.filter(upgrade => upgrade.currentLevel > 0).forEach(upgrade => {
                const upgradeDiv = document.createElement('div');
                upgradeDiv.className = `my-item-card p-3 border rounded-lg flex flex-col items-center gap-2 border-gray-700`;

                const nameSpan = document.createElement('span');
                nameSpan.className = 'text-white text-sm font-bold';
                nameSpan.textContent = upgrade.name;
                upgradeDiv.appendChild(nameSpan);

                const levelSpan = document.createElement('span');
                levelSpan.className = 'text-blue-300 text-xs';
                levelSpan.textContent = `ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ: ${upgrade.currentLevel} / ${upgrade.maxLevel}`;
                upgradeDiv.appendChild(levelSpan);

                const descSpan = document.createElement('span');
                descSpan.className = 'text-gray-400 text-xs text-center mt-1';
                descSpan.textContent = upgrade.description;
                upgradeDiv.appendChild(descSpan);
                myUpgradesContainer.appendChild(upgradeDiv);
            });
        }

        function resetGameData() {
            // Using browser's confirm for critical action
            if (confirm('ŸáŸÑ ÿ£ŸÜÿ™ ŸÖÿ™ÿ£ŸÉÿØ ÿ£ŸÜŸÉ ÿ™ÿ±ŸäÿØ ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ÿ¨ŸÖŸäÿπ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÑÿπÿ®ÿ©ÿü Ÿáÿ∞ÿß ŸÑÿß ŸäŸÖŸÉŸÜ ÿßŸÑÿ™ÿ±ÿßÿ¨ÿπ ÿπŸÜŸá!')) {
                localStorage.clear(); // Clear all local storage data
                // Reset in-memory variables
                gold = 0;
                dollars = 0;
                highScore = 0;
                totalGoldCollected = 0;
                totalDollarsCollected = 0;
                gamesPlayed = 0;
                playerLevel = 1;
                playerXP = 0;

                loadGameData(); // Reload default data
                updateProfileDisplay(); // Update profile UI
                renderShop(); // Update shop UI
                renderMyItems(); // Update my items UI

                goldScoreDisplay.textContent = `ÿßŸÑÿ∞Ÿáÿ®: ${gold}`;
                dollarScoreDisplay.textContent = `ÿßŸÑÿØŸàŸÑÿßÿ±: ${dollars}`;
                highScoreDisplay.textContent = `ÿ£ÿπŸÑŸâ ÿ∞Ÿáÿ®: ${highScore}`;
                showInGameNotification('ÿ™ŸÖÿ™ ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ÿ¨ŸÖŸäÿπ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÑÿπÿ®ÿ©!');
                myItemsModal.classList.remove('active');
                mainMenuModal.classList.add('active'); // Go back to main menu
            }
        }

        // --- Shop Functions ---

        /**
         * Renders the shop UI based on current skin and upgrade data.
         */
        function renderShop() {
            shopCurrentGoldDisplay.innerHTML = `${goldIconSVG} ÿßŸÑÿ∞Ÿáÿ® ÿßŸÑÿ≠ÿßŸÑŸä: ${gold}`;
            shopCurrentDollarsDisplay.innerHTML = `${dollarIconSVG} ÿßŸÑÿØŸàŸÑÿßÿ± ÿßŸÑÿ≠ÿßŸÑŸä: ${dollars}`;
            playerSkinsContainer.innerHTML = '';
            obstacleSkinsContainer.innerHTML = '';
            upgradesContainer.innerHTML = ''; // Clear upgrades container

            // Render Player Skins
            playerSkins.forEach(skin => {
                const skinDiv = document.createElement('div');
                skinDiv.className = `skin-item p-3 border rounded-lg flex flex-col items-center gap-2 ${skin.isActive ? 'active border-green-500' : 'border-gray-700'} transition-all duration-200`;

                const previewCanvas = document.createElement('canvas');
                previewCanvas.width = 60;
                previewCanvas.height = 60;
                previewCanvas.className = 'skin-preview';
                const previewCtx = previewCanvas.getContext('2d');
                previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                previewCtx.save();
                const scale = 0.8;
                previewCtx.translate(previewCanvas.width / 2, previewCanvas.height / 2);
                previewCtx.scale(scale, scale);
                previewCtx.translate(-previewCanvas.width / 2, -previewCanvas.height / 2);
                const previewYOffset = skin.id.startsWith('ship') ? 10 : 0;
                skin.drawFunction(previewCtx, previewCanvas.width / 2, previewCanvas.height / 2 + previewYOffset, 40, 40, skin.color, skin.detailsColor);
                previewCtx.restore();

                skinDiv.appendChild(previewCanvas);

                const nameSpan = document.createElement('span');
                nameSpan.className = 'text-white text-sm font-bold';
                nameSpan.textContent = skin.name;
                skinDiv.appendChild(nameSpan);

                const button = document.createElement('button');
                button.className = `game-button text-xs px-2 py-1 ${skin.isActive ? 'bg-green-600 cursor-default' : ''}`;
                button.dataset.id = skin.id;
                button.dataset.type = 'player';

                if (skin.isOwned) {
                    button.textContent = skin.isActive ? 'ŸÖŸèÿ¨Ÿáÿ≤' : 'ÿ™ÿ¨ŸáŸäÿ≤';
                    button.disabled = skin.isActive;
                    button.classList.add('equip-button');
                } else {
                    let costText = '';
                    if (skin.cost.gold > 0) costText += `${skin.cost.gold} ${goldIconSVG}`;
                    if (skin.cost.dollars > 0) costText += `${skin.cost.dollars} ${dollarIconSVG}`;
                    button.innerHTML = `ÿ¥ÿ±ÿßÿ° (${costText.trim()})`;
                    button.classList.add('buy-button');
                }
                skinDiv.appendChild(button);
                playerSkinsContainer.appendChild(skinDiv);
            });

            // Render Obstacle Skins
            obstacleSkins.forEach(skin => {
                const skinDiv = document.createElement('div');
                skinDiv.className = `skin-item p-3 border rounded-lg flex flex-col items-center gap-2 ${skin.isActive ? 'active border-green-500' : 'border-gray-700'} transition-all duration-200`;

                const previewCanvas = document.createElement('canvas');
                previewCanvas.width = 60;
                previewCanvas.height = 60;
                previewCanvas.className = 'skin-preview';
                const previewCtx = previewCanvas.getContext('2d');
                previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                previewCtx.save();
                const scale = 0.8;
                previewCtx.translate(previewCanvas.width / 2, previewCanvas.height / 2);
                previewCtx.scale(scale, scale);
                previewCtx.translate(-previewCanvas.width / 2, -previewCanvas.height / 2);
                skin.drawFunction(previewCtx, previewCanvas.width / 2, previewCanvas.height / 2, 40, 40, skin.color, skin.detailsColor);
                previewCtx.restore();

                skinDiv.appendChild(previewCanvas);

                const nameSpan = document.createElement('span');
                nameSpan.className = 'text-white text-sm font-bold';
                nameSpan.textContent = skin.name;
                skinDiv.appendChild(nameSpan);

                const button = document.createElement('button');
                button.className = `game-button text-xs px-2 py-1 ${skin.isActive ? 'bg-green-600 cursor-default' : ''}`;
                button.dataset.id = skin.id;
                button.dataset.type = 'obstacle';

                if (skin.isOwned) {
                    button.textContent = skin.isActive ? 'ŸÖŸèÿ¨Ÿáÿ≤' : 'ÿ™ÿ¨ŸáŸäÿ≤';
                    button.disabled = skin.isActive;
                    button.classList.add('equip-button');
                } else {
                    let costText = '';
                    if (skin.cost.gold > 0) costText += `${skin.cost.gold} ${goldIconSVG}`;
                    if (skin.cost.dollars > 0) costText += `${skin.cost.dollars} ${dollarIconSVG}`;
                    button.innerHTML = `ÿ¥ÿ±ÿßÿ° (${costText.trim()})`;
                    button.classList.add('buy-button');
                }
                skinDiv.appendChild(button);
                obstacleSkinsContainer.appendChild(skinDiv);
            });

            // Render Upgrades
            gameUpgrades.forEach(upgrade => {
                const upgradeDiv = document.createElement('div');
                upgradeDiv.className = `upgrade-item p-3 border rounded-lg flex flex-col items-center gap-2 border-gray-700 transition-all duration-200`;

                const nameSpan = document.createElement('span');
                nameSpan.className = 'text-white text-sm font-bold';
                nameSpan.textContent = upgrade.name;
                upgradeDiv.appendChild(nameSpan);

                const levelSpan = document.createElement('span');
                levelSpan.className = 'text-blue-300 text-xs';
                levelSpan.textContent = `ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ: ${upgrade.currentLevel} / ${upgrade.maxLevel}`;
                upgradeDiv.appendChild(levelSpan);

                const descSpan = document.createElement('span');
                descSpan.className = 'text-gray-400 text-xs text-center mt-1';
                descSpan.textContent = upgrade.description;
                upgradeDiv.appendChild(descSpan);

                const button = document.createElement('button');
                button.className = `game-button text-xs px-2 py-1 mt-2`;
                button.dataset.id = upgrade.id;
                button.dataset.type = 'upgrade';

                if (upgrade.currentLevel < upgrade.maxLevel) {
                    const nextLevelCost = upgrade.levels[upgrade.currentLevel].cost;
                    let costText = '';
                    if (typeof nextLevelCost === 'object') { // If cost is an object (gold and dollars)
                        if (nextLevelCost.gold > 0) costText += `${nextLevelCost.gold} ${goldIconSVG}`;
                        if (nextLevelCost.dollars > 0) costText += `${nextLevelCost.dollars} ${dollarIconSVG}`;
                    } else { // If cost is just gold (number)
                        costText += `${nextLevelCost} ${goldIconSVG}`;
                    }
                    button.innerHTML = `ÿ™ÿ±ŸÇŸäÿ© (${costText.trim()})`;
                    button.classList.add('buy-upgrade-button');
                } else {
                    button.textContent = 'ÿ£ŸÇÿµŸâ ŸÖÿ≥ÿ™ŸàŸâ';
                    button.disabled = true;
                    button.classList.add('bg-gray-600', 'cursor-default');
                }
                upgradeDiv.appendChild(button);
                upgradesContainer.appendChild(upgradeDiv);
            });


            // Add event listeners to newly created buttons (delegation or re-attach)
            document.querySelectorAll('.buy-button').forEach(button => {
                button.onclick = (e) => buySkin(e.target.dataset.type, e.target.dataset.id);
            });
            document.querySelectorAll('.equip-button').forEach(button => {
                button.onclick = (e) => equipSkin(e.target.dataset.type, e.target.dataset.id);
            });
            document.querySelectorAll('.buy-upgrade-button').forEach(button => {
                button.onclick = (e) => buyUpgrade(e.target.dataset.id);
            });
        }

        // --- Cannon Game Functions ---

        function initCannonGame() {
            cannonGameCanvas.width = cannonGameCanvas.offsetWidth;
            cannonGameCanvas.height = cannonGameCanvas.offsetHeight;

            cannonGameScore = 0;
            cannonGoldReward = 0;
            cannonBalls = [];
            cannonTargets = [];
            cannonGameLevel = 1;

            cannon.x = cannonGameCanvas.width / 2;
            cannon.y = cannonGameCanvas.height - 30;
            cannon.angle = Math.PI / 2; // Straight up

            generateCannonTargets();
            chooseNextCannonBallColor();
            updateCannonGameUI();
        }

        function generateCannonTargets() {
            cannonTargets = [];
            const startY = 50;
            const startX = (cannonGameCanvas.width - (CANNON_TARGET_COLUMNS * (CANNON_TARGET_SIZE + CANNON_TARGET_SPACING))) / 2;

            for (let row = 0; row < CANNON_TARGET_ROWS; row++) {
                for (let col = 0; col < CANNON_TARGET_COLUMNS; col++) {
                    const targetX = startX + col * (CANNON_TARGET_SIZE + CANNON_TARGET_SPACING);
                    const targetY = startY + row * (CANNON_TARGET_SIZE + CANNON_TARGET_SPACING);
                    const colorIndex = Math.floor(Math.random() * CANNON_COLORS.length);
                    cannonTargets.push({
                        x: targetX,
                        y: targetY,
                        width: CANNON_TARGET_SIZE,
                        height: CANNON_TARGET_SIZE,
                        color: CANNON_COLORS[colorIndex]
                    });
                }
            }
        }

        function chooseNextCannonBallColor() {
            const randomIndex = Math.floor(Math.random() * CANNON_COLORS.length);
            currentCannonBallColor = CANNON_COLORS[randomIndex];
        }

        function drawCannonGame() {
            cannonCtx.clearRect(0, 0, cannonGameCanvas.width, cannonGameCanvas.height);

            // Draw Cannon
            cannonCtx.save();
            cannonCtx.translate(cannon.x, cannon.y);
            cannonCtx.rotate(cannon.angle - Math.PI / 2); // Adjust for drawing upright
            cannonCtx.fillStyle = cannon.color;
            cannonCtx.fillRect(-cannon.height / 2, -cannon.width / 2, cannon.height, cannon.width); // Draw rectangle as cannon barrel
            cannonCtx.restore();

            // Draw Next Ball Indicator
            cannonCtx.fillStyle = currentCannonBallColor;
            cannonCtx.beginPath();
            cannonCtx.arc(cannon.x, cannon.y + 20, CANNON_BALL_RADIUS, 0, Math.PI * 2);
            cannonCtx.fill();
            cannonCtx.strokeStyle = 'white';
            cannonCtx.lineWidth = 1;
            cannonCtx.stroke();
            cannonCtx.font = '12px Cairo';
            cannonCtx.fillStyle = 'white';
            cannonCtx.textAlign = 'center';
            cannonCtx.fillText('ÿßŸÑÿ™ÿßŸÑŸä', cannon.x, cannon.y + 20 + CANNON_BALL_RADIUS + 10);


            // Draw Cannon Balls
            cannonBalls.forEach(ball => {
                cannonCtx.fillStyle = ball.color;
                cannonCtx.beginPath();
                cannonCtx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                cannonCtx.fill();
            });

            // Draw Cannon Targets
            cannonTargets.forEach(target => {
                cannonCtx.fillStyle = target.color;
                cannonCtx.fillRect(target.x, target.y, target.width, target.height);
                cannonCtx.strokeStyle = 'white';
                cannonCtx.lineWidth = 2;
                cannonCtx.strokeRect(target.x, target.y, target.width, target.height);
            });
        }

        function updateCannonGame() {
            // Update Cannon Balls
            cannonBalls = cannonBalls.filter(ball => {
                ball.x += ball.vx;
                ball.y += ball.vy;

                // Check collision with targets
                for (let i = cannonTargets.length - 1; i >= 0; i--) {
                    const target = cannonTargets[i];
                    if (
                        ball.x + ball.radius > target.x &&
                        ball.x - ball.radius < target.x + target.width &&
                        ball.y + ball.radius > target.y &&
                        ball.y - ball.radius < target.y + target.height
                    ) {
                        if (ball.color === target.color) {
                            cannonGameScore += 100; // Score for matching
                            cannonTargets.splice(i, 1); // Remove target
                            addXP(10); // Add XP for cannon game
                            updateCannonGameUI();
                            return false; // Remove ball
                        }
                    }
                }

                // Remove ball if off-screen
                return ball.x > -ball.radius && ball.x < cannonGameCanvas.width + ball.radius &&
                       ball.y > -ball.radius && ball.y < cannonGameCanvas.height + ball.radius;
            });

            // Check if all targets cleared, regenerate
            if (cannonTargets.length === 0) {
                cannonGameLevel++;
                cannonTargetSpawnInterval = Math.max(500, cannonTargetSpawnInterval - 100); // Make it faster
                generateCannonTargets();
                showInGameNotification(`ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ ${cannonGameLevel} ŸÅŸä ŸÑÿπÿ®ÿ© ÿßŸÑŸÖÿØŸÅÿπ!`);
            }

            // Award gold for score
            if (cannonGameScore >= cannonGameScoreToGold) {
                const goldEarned = Math.floor(cannonGameScore / cannonGameScoreToGold);
                gold += goldEarned;
                totalGoldCollected += goldEarned;
                cannonGoldReward += goldEarned;
                cannonGameScore %= cannonGameScoreToGold; // Reset score remainder
                goldScoreDisplay.textContent = `ÿßŸÑÿ∞Ÿáÿ®: ${gold}`;
                showInGameNotification(`ÿ≠ÿµŸÑÿ™ ÿπŸÑŸâ ${goldEarned} ÿ∞Ÿáÿ® ŸÖŸÜ ŸÑÿπÿ®ÿ© ÿßŸÑŸÖÿØŸÅÿπ!`);
                saveGameData();
            }
        }

        function fireCannonBall() {
            const velocityX = CANNON_BALL_SPEED * Math.cos(cannon.angle);
            const velocityY = CANNON_BALL_SPEED * Math.sin(cannon.angle);
            cannonBalls.push({
                x: cannon.x,
                y: cannon.y,
                radius: CANNON_BALL_RADIUS,
                color: currentCannonBallColor,
                vx: velocityX,
                vy: velocityY
            });
            chooseNextCannonBallColor(); // Get next ball color
            updateCannonGameUI();
        }

        function updateCannonGameUI() {
            cannonGameScoreDisplay.textContent = cannonGameScore;
            cannonGameGoldRewardDisplay.textContent = cannonGoldReward;
        }

        function cannonGameLoop() {
            try {
                updateCannonGame();
                drawCannonGame();
            } catch (error) {
                console.error("Error in Cannon Game loop:", error);
                endCannonGame(); // End game on error
                showMessageBox("ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ŸÑÿπÿ®ÿ© ÿßŸÑŸÖÿØŸÅÿπ! ÿ™ŸÖ ÿ•ŸäŸÇÿßŸÅ ÿßŸÑŸÑÿπÿ®.");
            }

            if (cannonGameRunning) {
                requestAnimationFrame(cannonGameLoop);
            }
        }

        function startCannonGame() {
            // Hide all other modals
            mainMenuModal.classList.remove('active');
            shopModal.classList.remove('active');
            profileModal.classList.remove('active');
            myItemsModal.classList.remove('active');

            // Hide Sea King game elements
            canvas.style.display = 'none';
            gameButtons.style.display = 'none';
            goldScoreDisplay.style.display = 'none';
            dollarScoreDisplay.style.display = 'none';
            highScoreDisplay.style.display = 'none';
            powerupsDisplay.style.display = 'none';

            // Show Cannon Game elements
            cannonGameModal.classList.add('active');
            cannonGameCanvas.style.display = 'block';

            initCannonGame(); // Initialize cannon game state
            cannonGameRunning = true; // Start cannon game loop
            cannonGameLoop();
        }

        function endCannonGame() {
            cannonGameRunning = false; // Stop cannon game loop
            cannonGameModal.classList.remove('active');
            mainMenuModal.classList.add('active'); // Go back to main menu
            saveGameData(); // Save any earned gold/XP
        }


        // --- Event Listeners ---

        // Keyboard controls for Sea King
        document.addEventListener('keydown', e => {
            if (gameRunning) {
                if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                    player.dx = player.speed;
                } else if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                    player.dx = -player.speed;
                }
            }
        });

        document.addEventListener('keyup', e => {
            if (gameRunning && (e.key === 'ArrowRight' || e.key === 'ArrowLeft' || e.key === 'd' || e.key === 'D' || e.key === 'a' || e.key === 'A')) {
                player.dx = 0; // Stop movement when key is released
            }
        });

        // Touch controls for Sea King: Tap and hold left/right half of the screen
        canvas.addEventListener('touchstart', e => {
            if (gameRunning) {
                const touchX = e.touches[0].clientX;
                const canvasRect = canvas.getBoundingClientRect(); // Get canvas position on screen
                const relativeX = touchX - canvasRect.left; // Calculate touch X relative to canvas

                if (relativeX < canvas.width / 2) {
                    player.dx = -player.speed; // Move left if touch is on left half
                } else {
                    player.dx = player.speed; // Move right if touch is on right half
                }
                e.preventDefault(); // Prevent scrolling/zooming on touch
            }
        }, { passive: false }); // Set passive to false to allow preventDefault

        canvas.addEventListener('touchend', () => {
            if (gameRunning) {
                player.dx = 0; // Stop movement when touch ends
            }
        });

        // Cannon Game Controls (Mouse/Touch for aiming and firing)
        let isAiming = false;
        cannonGameCanvas.addEventListener('mousedown', e => {
            if (cannonGameRunning) {
                isAiming = true;
                const rect = cannonGameCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                cannon.angle = Math.atan2(mouseY - cannon.y, mouseX - cannon.x);
                drawCannonGame(); // Redraw to show new angle
            }
        });

        cannonGameCanvas.addEventListener('mousemove', e => {
            if (cannonGameRunning && isAiming) {
                const rect = cannonGameCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                cannon.angle = Math.atan2(mouseY - cannon.y, mouseX - cannon.x);
                drawCannonGame();
            }
        });

        cannonGameCanvas.addEventListener('mouseup', () => {
            if (cannonGameRunning && isAiming) {
                isAiming = false;
                fireCannonBall();
            }
        });

        cannonGameCanvas.addEventListener('touchstart', e => {
            if (cannonGameRunning) {
                isAiming = true;
                const rect = cannonGameCanvas.getBoundingClientRect();
                const touchX = e.touches[0].clientX - rect.left;
                const touchY = e.touches[0].clientY - rect.top;
                cannon.angle = Math.atan2(touchY - cannon.y, touchX - cannon.x);
                drawCannonGame();
                e.preventDefault();
            }
        }, { passive: false });

        cannonGameCanvas.addEventListener('touchmove', e => {
            if (cannonGameRunning && isAiming) {
                const rect = cannonGameCanvas.getBoundingClientRect();
                const touchX = e.touches[0].clientX - rect.left;
                const touchY = e.touches[0].clientY - rect.top;
                cannon.angle = Math.atan2(touchY - cannon.y, touchX - cannon.x);
                drawCannonGame();
                e.preventDefault();
            }
        }, { passive: false });

        cannonGameCanvas.addEventListener('touchend', () => {
            if (cannonGameRunning && isAiming) {
                isAiming = false;
                fireCannonBall();
            }
        });


        // Main Menu Button Listeners
        mainMenuPlayButton.addEventListener('click', startGame);
        mainMenuShopButton.addEventListener('click', () => {
            mainMenuModal.classList.remove('active');
            shopModal.classList.add('active');
            renderShop();
        });
        mainMenuProfileButton.addEventListener('click', openProfile);
        mainMenuCannonGameButton.addEventListener('click', startCannonGame); // New listener for Cannon Game

        // Game Screen Button Listeners (initially hidden)
        startButton.addEventListener('click', startGame);
        resetButton.addEventListener('click', startGame);
        shopButton.addEventListener('click', () => {
            gameButtons.style.display = 'none'; // Hide game buttons
            shopModal.classList.add('active');
            renderShop();
        });

        // Modal Close Buttons
        messageBoxClose.addEventListener('click', hideMessageBox);
        shopCloseButton.addEventListener('click', () => {
            shopModal.classList.remove('active');
            mainMenuModal.classList.add('active'); // Go back to main menu
            // Hide game elements when returning to main menu
            canvas.style.display = 'none';
            gameButtons.style.display = 'none';
            goldScoreDisplay.style.display = 'none';
            dollarScoreDisplay.style.display = 'none';
            highScoreDisplay.style.display = 'none';
            powerupsDisplay.style.display = 'none';
        });
        profileCloseButton.addEventListener('click', () => {
            profileModal.classList.remove('active');
            mainMenuModal.classList.add('active'); // Go back to main menu
            // Hide game elements when returning to main menu
            canvas.style.display = 'none';
            gameButtons.style.display = 'none';
            goldScoreDisplay.style.display = 'none';
            dollarScoreDisplay.style.display = 'none';
            highScoreDisplay.style.display = 'none';
            powerupsDisplay.style.display = 'none';
        });

        // My Items Button and Close
        myItemsButton.addEventListener('click', openMyItems);
        myItemsCloseButton.addEventListener('click', () => {
            myItemsModal.classList.remove('active');
            profileModal.classList.add('active'); // Go back to profile
        });
        resetGameDataButton.addEventListener('click', resetGameData); // This button is now inside My Items modal

        // Cannon Game Back Button
        cannonGameBackButton.addEventListener('click', endCannonGame);


        // Handle canvas resizing
        window.addEventListener('resize', () => {
            // Update Sea King canvas dimensions
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            // Recenter player if game is running or not
            player.x = canvas.width / 2;
            player.y = canvas.height - 60; // Keep at bottom

            // Update Cannon Game canvas dimensions
            cannonGameCanvas.width = cannonGameCanvas.offsetWidth;
            cannonGameCanvas.height = cannonGameCanvas.offsetHeight;
            cannon.x = cannonGameCanvas.width / 2;
            cannon.y = cannonGameCanvas.height - 30;


            // Redraw immediately if no game is running (e.g., in main menu)
            if (!gameRunning && !cannonGameRunning) {
                draw(); // Redraw Sea King canvas (will be hidden anyway)
                drawCannonGame(); // Redraw Cannon game canvas (will be hidden anyway)
            }
            // If a game is running, its loop will handle the updated positions
        });

        // Initial setup when the window loads
        window.onload = function() {
            loadGameData(); // Load skins and high score
            // Set initial canvas sizes
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            cannonGameCanvas.width = cannonGameCanvas.offsetWidth;
            cannonGameCanvas.height = cannonGameCanvas.offsetHeight;

            draw(); // Draw initial state of Sea King (will be hidden)
            drawCannonGame(); // Draw initial state of Cannon Game (will be hidden)

            // Initially hide game elements
            canvas.style.display = 'none';
            gameButtons.style.display = 'none';
            goldScoreDisplay.style.display = 'none';
            dollarScoreDisplay.style.display = 'none';
            highScoreDisplay.style.display = 'none';
            powerupsDisplay.style.display = 'none';
            cannonGameModal.classList.remove('active'); // Ensure cannon game is hidden

            // Show the main menu
            mainMenuModal.classList.add('active');
        };
    </script>
</body>
</html>
